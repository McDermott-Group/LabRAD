# Copyright (C) 2015 Guilhem Ribeill, Ivan Pechenezhskiy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
Base class for all python-based LabRAD experiments. This class should be
the parent class for a particular experiment. It provides shared 
functionality for setting experiment variables, electronics 
initialization, running single point experiments as well as 1D- and 2D-
sweeps, and saving data to text and MATLAB .mat files. Particular 
experiments should be generated by using this as a parent class.

A basic experiment program would look something like this:

with SomeExperiment.Experiment() as expt:    
    expt.set_experiment(information, resources, variables) 
    freq = np.linspace(2e9, 5e9, 101) * GHz
    expt.sweep('RF Frequency', freq, save=True)
"""

import os
if __file__ in [f for f in os.listdir('.') if os.path.isfile(f)]:
    # This is executed when the script is loaded by the labradnode.
    SCRIPT_PATH = os.path.dirname(os.getcwd())
else:
    # This is executed if the script is started by clicking or
    # from a command line.
    SCRIPT_PATH = os.path.dirname(__file__)
LABRAD_PATH = os.path.join(SCRIPT_PATH.rsplit('LabRAD', 1)[0])
import sys
if LABRAD_PATH not in sys.path:
    sys.path.append(LABRAD_PATH)

import time
import warnings
import itertools
from msvcrt import kbhit, getch

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cbook
warnings.filterwarnings("ignore", category=matplotlib.cbook.mplDeprecation)
import scipy.io as sio

import labrad
import labrad.units as units

import LabRAD.Servers.Instruments.GHzBoards.ghz_fpga_control as ghz_fpga_control


class ExperimentDefinitionError(Exception): pass
class DataError(Exception): pass
class SweepError(Exception): pass


class Experiment:
    """
    Experiment class. Parent class for specific instances of experiments
    that provides shared functionality.
    """
###SPECIAL METHODS##############################################################
    def __init__(self):
        """
        Input:
            None.
        Output:
            None.
        """ 
        self._cxn = labrad.connect()
        # This flag controls the standard output upon pressing [O]
        # during a experiment sweep.
        self._standard_output = True

    def __del__(self):
        """Just in case..."""
        plt.close('all')
        
    def __enter__(self):
        """
        Context entry. For now all it does is return a copy of 
        the initialized class.
        """
        return self
    
    def __exit__(self,type, value, traceback):
        """
        Safely close all connections, close plots, and disconnect from 
        LabRAD. Catch exceptions if needed.
        """
        self._cxn.disconnect()
        print('The instrument resources have been safely terminated! ' + 
              'Have a nice day.')
  
    ###SETUP METHODS############################################################
    def set_experiment(self, information, resources, variables):
        """
        Sets experiment information, resources and experiment variables.
        
        Inputs:
            information: dictionary that should have the following 
                parameters (as strings):
                1. Device Name: Name of the resource under study
                2. User: Who is running the experiment?
                3. Base Path: initial path for data saving purposes.
                4. Experiment Name: what are you doing?
                5. Comments: any comments that will go in the header 
                    file of each saved data file (optional, will be 
                    blank if not included).
            resources: list of resources in the following format:
              [ { # Generic device
                    'Resource': 'device name'
                    'Server': 'server name',
                    'Address': 'address that could be used to select 
                        the device',
                    'Variables': {
                                    'Variable 1': 'server setting that 
                                        controls Variable 1', 
                                    'Variable 2': 'server setting that
                                        controls Variable 2'
                                 }
                },
                { # Waveform parameters.
                    'Resource': 'GHz Boards', 
                    'Server': 'GHz FPGAs'
                    'Variables': ['Pulse 1 Length', 'Pulse 2 Length']
                },
                { # DACs are converted to a simple ordered list 
                  # internally based on 'List Index' value.
                    'Resource': 'DAC',
                    'DAC Name': 'Board DAC 1',
                    'List Index': 0,
                    'DAC Settings': {
                                        'DAC A': 'RF I',
                                        'DAC B': 'RF Q',
                                        'FO1 FastBias Firmware Version':
                                            '2.1'
                                    },
                    'Variables': []
                },
                { # ADCs are converted to a simple ordered list 
                  # internally based on 'List Index' value.  
                    'Resource': 'ADC',
                    'ADC Name': 'Board ADC 3',
                    'List Index': 0,
                    'ADC Settings': { # These default settings might be 
                                      # over-written by the Experiment 
                                      # methods. 
                                        'RunMode': 'demodulate', 
                                            # or 'average'
                                        'FilterType': 'square',
                                        'FilterWidth': 9500,
                                        'FilterLength': 10000,
                                        'filterStretchAt': 0,
                                        'filterStretchLen': 0,
                                        'DemodPhase': 0,
                                        'DemodCosAmp': 255,
                                        'DemodSinAmp': 255,
                                        'DemodFreq': -30 * units.MHz,
                                        'ADCDelay': 0
                                    },
                    'Variables': ['ADC Time'],
                },
                { # GPIB RF Generator.
                    'Resource': 'RF Generator',
                    'Server': 'GPIB RF Generators',
                    'Address': 'GPIB Bus - GPIB0::10',
                    'Variables': {
                                    'RF Power': 'Power', 
                                    'RF Frequency': 'Frequency'
                                 }
                },
                { # Lab Brick Attenuator.
                    'Resource': 'Lab Brick Attenuator',
                    'Server': 'Lab Brick Attenuators',
                    'Address': 7032,
                    'Variables': 'RF Attenuation'
                { # SIM Voltage Source.
                    'Resource': 'Voltage Source',
                    'Server': 'SIM928',
                    'Address': 'GPIB0::10::SIM900::3',
                    'Variables': ['Bias Voltage']
                },
                { # External readings.
                    'Resource': 'Manual Record',
                    'Variables': ['Temperature']
                },
                { # Extra experiment parameters.
                    'Resource': 'Software Parameters',
                    'Variables': ['Runs'],
                }
              ]
            variables: experiment variable dictionary 
                in the {'Variable Name': Value,...} format.
        Output:
            None.
        """
        self._set_information(information)
        self._set_resources(resources)
        self._set_variables(variables)
        
    def _set_information(self, information):
        """
        Sets experiment information, as well as base path for saving. 
        Base path will be: Base Path\User\Device\Date\Experiment Name\
        
        Input:
            information: dictionary (see set_experiment method for more 
                information).
        Output:
            None.
        """
        # Check that all variables are in information as expected.   
        if 'Device Name' not in information:
            raise ExperimentDefinitionError('Device name is not specified.')
        if 'User' not in information:
            raise ExperimentDefinitionError('User is not specified.')
        if 'Base Path' not in information:
            raise ExperimentDefinitionError('Base path is not specified.')
        if 'Experiment Name' not in information:
            raise ExperimentDefinitionError('Experiment name is not specified.')
        if 'Comments' not in information:
            information['Comments'] = ''

        self.information = information
        
        # Make the base path if it does not exist.
        if not os.path.exists(information['Base Path']):
            try:
                os.makedirs(information['Base Path'])
            except:
                raise IOError('Could not create base path! Is AFS on?')
        
        # Get today's date in MM-DD-YY format, and make the save path.
        today = time.strftime("%m-%d-%y", time.localtime())
        self._save_path = os.path.join(information['Base Path'],
                                       information['User'],
                                       information['Device Name'],
                                       today,
                                       information['Experiment Name'])
        if not os.path.exists(self._save_path):
            try:
                os.makedirs(self._save_path)
            except:
                raise IOError('Could not create experiment save path!' + 
                              ' Is AFS on?')
    
    def _add_vars(self, resource):
        """
        Add experiment variables to self._vars from a resource. Specify 
        some extra information that is may be required by other methods.
        
        Input:
            resource: a resource dictionary from a list of experiment 
            resources.
        Output:
            None.
        """
        res = resource.copy()
        res.pop('Variables', None)
        if isinstance(resource['Variables'], str):
            self._vars[resource['Variables']] = res
        elif isinstance(resource['Variables'], list):
            for var in resource['Variables']:
                self._vars[var] = res.copy()
        elif iniinstance(resource['Variables'], dict):
            for var in resournce['Varibales']:
                res['Setting'] = resource['Variables'][var]
                self._vars[vars] = res.copy()
        else:
            raise ExperimentDefinitionError("Variables in the resource" + 
                " dictionary " + str(resource) +
                " should be specified as a list of strings, a dictionary," + 
                " or just as a simple string for a single variable.")
    
    def _set_resources(self, resources):
        """
        Set electronics information (what dacs, adcs, and RF generators,
        Lab Bricks, etc. we are running), initializes connections to the
        LabRAD servers.
        
        This methods also creates a map of the experiment variables 
        defined in resources to these resources.
        
        Input:
            resources: a list of resource dictionaries (see 
                set_experiment method for more information).
        Output:
            None.
        """
        self._vars = {}     # Dictionary of the experiment variables.
        self.fpga_server = None     # LabRAD Server.
        dacs = {}           # Dictionary of DAC boards with the list index as a key.
        adcs = {}           # Dictionary of ADC boards with the list index as a key.
        dac_settings = {}   # Dictionary of DAC board settings with the list index as a key.
        adc_settings = {}   # Dictionary of ADC board settings with the list index as a key.
        
        def _msg(key, resource):
            return ("'" + key + "' key is not found in the resource " + 
                   " dictionary: " + str(resource) + ".")
        
        for resource in resources:
            if 'Resource' not in resource:
                raise ExperimentDefinitionError(_msg('Resource', resource))
            if 'Variables' not in resource:
                raise ExperimentDefinitionError(_msg('Variables', resource))
            else:
                if (not isinstance(resource['Variables'], str) and 
                    not isinstance(resource['Variables'], list) and
                    not isinstance(resource['Variables'], dict)):
                    raise ExperimentDefinitionError("'Variables' key" +
                    " in the resource dictionary: " + str(resource) +
                    " should be defined as a list of experiment" + 
                    " variables or as a simple string for a single variable.")
            
            self._add_vars(resource)
            
            # Lab Bricks attenuators, RF generators and voltage sources.
            if resource['Resource'].lower() in ['lab brick attenuator', 
                    'rf generator', 'voltage source']:
                if 'Server' not in resource:
                    raise ExperimentDefinitionError(_msg('Server', resource))
                if 'Address' not in resource:
                    raise ExperimentDefinitionError(_msg('Address', resource))
                for var in resource['Variables']:
                    if resource['Resource'].lower() == 'lab brick attenuator':
                        self._vars[var]['Select Device'] = 'Select Attenuator'
                        if 'Setting' not in self._vars[var]:
                            self._vars[var]['Setting'] = 'Attenuation'
                    elif resource['Resource'].lower() == 'rf generator':
                        self._vars[var]['Select Device'] = 'Select Device'
                    elif resource['Resource'].lower() == 'voltage source':
                        self._vars[var]['Select Device'] = 'Select Device'
                        if 'Setting' not in self._vars[var]:
                            self._vars[var]['Setting'] = 'Voltage'

            # Link to GHz FPGAs server.         
            elif resource['Resource'] == 'GHz FPGA Boards':
                if 'Server' not in resource:
                    raise ExperimentDefinitionError(_msg('Server', resource))
                self.fpga_server = self.cxn[resource['Server']]

            # Specify DAC boards.
            elif resource['Resource'] == 'DAC':
                if 'DAC Name' not in resource:
                    raise ExperimentDefinitionError(_msg('DAC Name', resource))
                if 'List Index' not in resource:
                    raise ExperimentDefinitionError(_msg('List Index', resource))
                if 'DAC Settings' not in resource:
                    raise ExperimentDefinitionError(_msg('DAC Settings', resource))
                for channel in ['DAC A', 'DAC B']:
                    if channel not in resource['DAC Settings']:
                        raise ExperimentDefinitionError("'" + 
                        str(channel) + "' key is not found in the " + 
                        "'DAC Settings' dictionary: " +
                        str(resource['DAC Settings']) + " in '" + 
                        str(resource['DAC Name']) + "'.")    
                dacs[resource['List Index']] = resource['DAC Name']
                dac_settings[resource['List Index']] = resource['DAC Settings']
                self._add_vars(resource)
        
            # Specify ADC boards.
            elif resource['Resource'] == 'ADC':
                if 'ADC Name' not in resource:
                    raise ExperimentDefinitionError(_msg('ADC Name', resource))
                if 'List Index' not in resource:
                    raise ExperimentDefinitionError(_msg('List Index', resource))
                if 'ADC Settings' not in resource:
                    raise ExperimentDefinitionError(_msg('ADC Settings', resource))
                adcs[resource['List Index']] = resource['ADC Name']
                adc_settings[resource['List Index']] = resource['ADC Settings']
                self._add_vars(resource)

            elif resource['Resource'].lower() in ['manual record', 
                                                  'software parameters']:
                pass
            else:
                print("Warning: resource '" + str(resource['Resource']) +
                      "' is not yet supported.")

        # Check that all DAC and ADC boards are unique.
        if len(dacs.values()) != len(set(dacs.values())):
            raise ExperimentDefinitionError("All DAC boards must have" +
            " unique names in the resource dictionary. The following" + 
            " boards names are given: ", + str(dacs) + ".")
        if len(adcs.values()) != len(set(adcs.values())):
            raise ExperimentDefinitionError("All ADC boards must have" +
            " unique names in the resource dictionary. The following" +
            " boards names are given: ", + str(adcs) + ".")
            
        # Create lists with the DAC and ADC boards as well as lists 
        # with ADC and DAC settings according to the specified indecies.
        self._dacs = [dacs[index] for index in sorted(dacs)]
        self._adcs = [adcs[index] for index in sorted(adcs)]
        self._dac_settings = [dac_settings[index] for index in sorted(dacs)]
        self._adc_settings = [adc_settings[index] for index in sorted(adcs)]
    
    def _set_variables(self, variables):
        """
        Sets experiment variables.
        
        Inputs:
            variables: experiment variable dictionary 
                in the {'Variable Name': Value,...} format.
        Output:
            None.
        """
        if not hasattr(self, '_vars'):
            raise ExperimentDefinitionError('Experiment resources ' + 
            'should be set prior setting experiment variables.')
        
        for var in variables:
            if var in self._vars:
                self._vars[var]['Value'] = variables[var]
                self._vars[var]['Save'] = True
            else:
                print("Warning: variable '" + str(var) + 
                "' is not found in the experiment variables. " +
                "Unless the variable is explicitly used, " + 
                "its value will not be saved.")
                self._vars[var] = {'Save': False}
              
    def _check_var(self, var, value_check=True):
        """
        Asserts existence of an experiment variable
        
        Inputs:
            var: name of the experiment variable.
            value_check (optional): check whether the value is defined.
        Output:
            None.
        """        
        if not isinstance(var, str):
            raise ExperimentDefinitionError("'" + str(var) + "' is " +
            "expected to be a string that defines an experiment variable.")
        if var not in self._vars:
            raise ExperimentDefinitionError("'" + str(var) + "' variable" + 
            " is not found in the experiment resource dictionary.")
        if value_check and 'Value' not in self._vars[var]:
            raise ExperimentDefinitionError("'" + str(var) +
            "' variable value is not defined.")
    
    def add_var(self, var, value=None):
        """
        Asserts an experiment variable and returns its value.
        
        Inputs:
            var: name of the experiment variable.
            unit: units to convert to.
            value (optional): a new value to assign to the experiment 
                variable.
        Output:
            value: value of the experiment variable.
        """
        if not hasattr(self, '_vars'):
            raise ExperimentDefinitionError('Experiment resources ' + 
            'should be set prior accessing any variables.')
        
        if var in self._vars:
            if value is not None:
                self._vars[var]['Value'] = value
        else:
            self._vars[var] = {'Value': value}
            if value is not None:
                self._vars[var]['Save'] = True
            else:
                self._vars[var]['Save'] = False

        return self._vars[var]['Value']

    ###DATA SAVING METHODS#########################################################################
    def _text_save(self, data):
        """
        Save data in human-readable text data file, new and improved
        version with better support for multidimensional data saves.
        Saves a header containing all experiment variables, then sweep
        variables, and then all variables in the data dictionary.
        """
        textFileFolder = os.path.join(self._save_path, 'TextData')
        
        if not os.path.exists(textFileFolder):
            try:
                os.makedirs(textFileFolder)
            except:
                raise Exception('Could not create experiment text ' + 
                'data save path! Is AFS on?')
        
        # Which contents are files?
        onlyfiles = [f for f in os.listdir(textFileFolder) if os.path.isfile(os.path.join(textFileFolder, f))]
        ExptName = self.information['Experiment Name'].replace(" ", "_")
        # Which files start off with 'ExperimentName_'?
        files = [f.split('.')[0] for f in onlyfiles if f[:len(ExptName) + 1] == ExptName+'_']
        
        # Get file numbers and increment, or create first file if none in folder.
        nums = [int(f[-3:]) for f in files if f[-3:].isdigit()]
        if nums==[]:
            num = '000'
            fname = ExptName+'_' + num + '.txt'
        else:
            num = ("%03d" % (max(nums) + 1,))
            fname = ExptName + '_' + num +'.txt'
        
        # Create the file path.
        filePath = os.path.join(textFileFolder,fname)
        
        # Build a header for the file.
        h = []
        h.append(ExptName)
        h.append(time.asctime())
        h.append('====Experiment Parameters====')
    
        # Save only the variables that have been actually used.
        # Do not save the sweep variables in the header.
        for var in self._vars:
            if (var not in data and 'Save' in self._vars[var] and 
                    self._vars[var]['Save'] and 'Value' in self._vars[var]):
                h.append(var + ':   ' + self.val2str(self._vars[var]['Value'], True))

        if 'Comments' in self.information:
            h.append('Comments:   ' + self.information['Comments'])
        
        h.append('====Sweep Variables====')
        with file(filePath, 'w') as outfile:
            for k in h:
                outfile.write(k + '\n')
            
            # This is to avoid duplicative saving of the sweep variables
            # when a parallel scan was run with the same variable name.
            for key in data:
                if ('Type' in data[key] and 'Value' in data[key] and 
                    data[key]['Type'] == 'Independent'):
                        outfile.write(key + self.get_units(key, True) + ':' +
                        str(list(np.shape(data[key]['Value']))) + '\n')
                        self._ndarray_text_save(outfile, 
                                self.strip_units(data[key]['Value']))

            outfile.write('====Data Variables====\n');
            for key in data:
                if ('Type' in data[key] and 'Value' in data[key] and 
                    data[key]['Type'] == 'Dependent'):
                    extra = ''
                    if 'Dependencies' in data[key]:
                        extra = '::' + str(data[key]['Dependencies'])
                    if 'Distribution' in data[key]:
                        extra = extra + ':::[' + data[key]['Distribution'] + ']'
                    outfile.write(key + self.get_units(data[key]['Value'], True) + 
                            ':' + str(list(np.shape(data[key]['Value']))) +
                            extra + '\n')
                    self._ndarray_text_save(outfile, 
                            self.strip_units(data[key]['Value']))
                    
    def _ndarray_text_save(self, outfile, array):
        """
        Write numpy.ndarray into a text file.
        
        Inputs:
            outfile: file handle to write the data into.
            array: numpy.ndarray to append to the end of a specified 
                file.
        Output:
            None.
        """
        if array.ndim == 1 or array.ndim == 2:
            np.savetxt(outfile, array, fmt = '%-7.6f', delimiter='\t')
        elif array.ndim > 2:
            for idx in range(array.shape[0]):
                self._ndarray_text_save(outfile, array[idx])
                
    def _mat_save(self, data):
        """
        Save data as a .mat file using scipi.io. Data will be saved as
        a structure, with a substructure for the experiment and 
        electronics, and arrays for the data.
        """
        MATLABFileFolder = os.path.join(self._save_path, 'MATLABData')
        
        if not os.path.exists(MATLABFileFolder):
            try:
                os.makedirs(MATLABFileFolder)
            except:
                raise Exception('Could not create experiment MATLAB ' + 
                'data save path! Is AFS on?')
        
        # Which contents are files?
        onlyfiles = [f for f in os.listdir(MATLABFileFolder) if os.path.isfile(os.path.join(MATLABFileFolder,f))]
        ExptName = self.information['Experiment Name'].replace(" ", "_")
        # Which files start off with 'ExperimentName_'?
        files = [f.split('.')[0] for f in onlyfiles if f[:len(ExptName) + 1] == ExptName + '_']
        
        # Get file numbers and increment, or create first file if none in folder.
        nums = [int(f[-3:]) for f in files if f[-3:].isdigit()]
        if nums==[]:
            num = '000'
            fname = ExptName + '_' + num + '.mat'
        else:
            num = ("%03d" % (max(nums) + 1,))
            fname = ExptName + '_' + num + '.mat'
        
        filePath = os.path.join(MATLABFileFolder,fname)
        
        # Convert ExptVars names to a MATLAB-friendly format.
        # Save the variables that have been actually used.
        # Do not save here the experiment variables that are sweep variables.
        matData = {}
        matExptVars = {}
        matUnits = {}
        for var in self._vars:
            if (var not in data and 'Save' in self._vars[var] and 
                    self._vars[var]['Save'] and 'Value' in self._vars[var]):
                matExptVars[var.replace(" ", "_")] = self.strip_units(var)
                matUnits[var.replace(" ", "_")] = self.get_units(var)
        
        # Create dictionary that will be saved to a .mat file.
        saveDict = {
                    'Time': time.asctime(),
                    'Name': ExptName + '_' + num,
                    'ExptVars': matExptVars,
                    'Comments': self.information['Comments']
                   }
        
        for key in data:
            if 'Value' in data[key]:
                matData[key.replace(" ", "_")] = self.strip_units(data[key]['Value'])

        saveDict['Data'] = matData
        
        # Save the information about the data units and the expected distributions.
        matDatadistr = {}
        matDataDepend = {}
        for key in data:
            if 'Value' in data[key]:
                matUnits[key.replace(" ", "_")] = self.get_units(key)
                if 'Distribution' in data[key]:
                    matDatadistr[key.replace(" ", "_")] = data[key]['Distribution']
                if 'Dependencies' in data[key]:
                    matDataDepend[key.replace(" ", "_")] = str(data[key]['Dependencies']).replace(", ", ",").replace(" ", "_")
        if matUnits:
            saveDict['Units'] = matUnits
        if matDatadistr:
            saveDict['Distr'] = matDatadistr
        if matDataDepend:
            saveDict['Depend'] = matDataDepend
  
        sio.savemat(filePath, {saveDict['Name']: saveDict})                

    def _save_data(self, data):
        """
        Save data as in a text (.txt) and a MATLAB (.mat) file formats.
        """ 
        # Remove unnecessary dimensions. This means that independent
        # variables that contain only one value should be removed from
        # the specifications.
        # from the dependency specifications and independent variables.
        rm_vars = []
        for key in data:
            if ('Value' in data and 'Type' in data and
                data[key]['Type'] == 'Independent' and
                np.size(data[key]['Value']) == 1):
                    data.pop(key)
                    rm_vars.append(key)
        # Remove unnecessary dimensions that contain only one value.
        for key in data:
            if 'Value' in data[key]:
                data[key]['Value'] = np.squeeze(data[key]['Value'])
            if 'Depenendecies' in data[key]:
                data[key]['Dependencies'] = [var for var 
                        in data[key]['Dependencies'] if var not in rm_vars]
            # Convert single numbers (zero-dimensional numpy arrays) 
            # to one-dimensional numpy arrays.
            if np.size(data[key]) == 1:
                data[key] = np.array([data[key]])
        
        self._text_save(data)
        self._mat_save(data)
        print('The data has been saved.')
    
    ###UTILITIES###################################################################################
    def get_units(self, v, brackets=False):
        """
        Return variable units.
        
        Input:
            v: value or name of the variable.
            brackets: boolean that specifies whether the variable units 
                should be enclosed in brackets (default: False).
        Output:
            units: units the variable is specified with. 
        """
        def _place_in_brackets(unit):
            if brackets and unit != '':
                return ' [' + unit + ']'
            else:
                return unit
        print('v = ' + v)
        if isinstance(v, (int, long, float, complex)):
            return ''
        if isinstance(v, units.Value):
            return _place_in_brackets(str(units.Unit(v)))
        if isinstance(v, np.ndarray):
            if any([isinstance(val, units.Value) in v.flatten()]):
                u = list(set([units.Unit(val) for val in v.flatten()]))
                if len(u) > 1:
                    raise Exception("More than one physical unit is found: " + 
                    str(u) + ".")
                else:
                    return _place_in_brackets(str(units.Unit(u[0])))
            else:
                return ''
        if v in self._vars:
            if 'Value' in self._vars[v]:
                value = self._vars[v]['Value']
                if isinstance(value, units.Value):
                    return _place_in_brackets(str(units.Unit(value)))
                else:
                    return ''
            else:
                raise ExperimentDefinitionError("No value is assigned" + 
                " to variable '" + str(v) + "'.")
            
    def strip_units(self, v):
        """
        Return variable value as a float number without any units. 
        Use this method only when it is really necessary to do so.
        
        Input:
            v: value or name of the variable.
        Output:
            number: numerical value of the variable. 
        """
        if isinstance(v, (int, long, float, complex)):
            return v
        if isinstance(v, units.Value):
            return v[units.Unit(v)]
        if isinstance(var, np.ndarray):
            return np.vectorize(self.strip_units)(v)
        if v in self._vars:
            if 'Value' in self._vars[v]:
                if isinstance(self._vars[v]['Value'], units.Value):
                    return self._vars[var]['Value'][units.Unit(self._vars[v]['Value'])]
                else:
                    return self._vars[var]['Value']
            else:
                raise ExperimentDefinitionError("No value is assigned" +
                " to variable '" + str(var) + "'.")
        else:
            raise ExperimentDefinitionError("Variable '" + str(var) + 
            "' is not found in the variable dictionary: " + 
            str(self._vars) + ".")
    
    def val2str(self, val, brackets=False):
        """
        Return variable units.
        
        Input(s):
            val: value of a physical quantity or a unitless number.
            brackets: boolean that specifies whether the variable units
                should be enclosed in brackets (default: False).
        Output:
            string: string representing the physical quantity or
                a unitless number.
        """
        if isinstance(val, units.Value) and brackets:
            return (str(val[units.Unit(val)]) + ' [' + 
                    str(units.Unit(val)) + ']')
        else:
            return str(val)
            
    def _combine_strs(*args):
        """
        Combine strings and lists of strings and return a list of 
        strings with unique elements.
        
        Inputs:
            *args: strings and/or lists of strings.
        Output:
            list of strings: flatten list containing only unique 
                strings. 
        """
        vars = []
        for arg in args:
            if arg is not None:
                if isinstance(arg, str):
                    vars = vars + [arg]
                elif isinstance(arg, list):
                    if any([not isinstance(var, str) for var in arg]):
                        print('Warning: internal method _combine_strs' +
                        ' can only accept strings or lists of strings' +
                        ' as its arguments.')
                    else:
                        vars = vars + arg
        result = []
        for var in vars:
            if var not in result:
                result.append(var)
        return result
    
    ###DATA POSTPROCESSING METHODS#################################################################
    def _software_demod(self, t, Is, Qs, adc_name=None):
        """
        Demodulate I and Q data in software. This method uses
        ADC frequency for demodulation. 
        
        Input:
            t: time vector during which to demodulate data (ns).
            Is: I data.
            Qs: Q data.
        Output:
            Id, Qd: demodulated I and Q.
        """
        demod = 2 * np.pi * t['ns'] * self._adc_settings[self._adcs.index(self._get_adc_name(adc_name))]['DemodFreq']['GHz']
        
        Sv = np.sin(demod)
        Cv = np.cos(demod)

        Id = np.mean(Is * Cv - Qs * Sv)
        Qd = np.mean(Is * Sv + Qs * Cv)
        
        return Id, Qd

    ###DAC AND ADC BOARD INTERFACE#######################################################################
    def load_and_run(self, sram, memory, reps=1000, experiment_type='PreAmp', adc_index=0):
        """
        Loads FPGA boards with the required memory and settings, and 
        executes the run sequence a set number of times. Should be 
        called at the end of each run_once. SRAM and Memory should be 
        lists which correspond to the the DAC SRAM and Memory in the 
        order in which they are defined in the Electronics information
        dictionary. The first listed DAC is always assumed to be the 
        master. 
        
        Inputs:
            sram: List of DAC SRAM waves. Use 
                ghz_fpga_control.waves2sram method to get the right 
                format.
            memory: List of memory commands. Use any of the memory tools
                in DAC_control to build a memory sequence.
            reps: number of repetitions in the sequence.
        Output:
            run_data: returns the result of the fpga.run_sequence 
                command.
        """
        if (len(sram)!=len(self._dacs))|(len(memory)!=len(self._dacs)):
            raise Exception('Not enough sram or DAC commands to populate the boards!')
        
        ghz_fpga_control.LoadDACs(self.fpga_server, memory, sram, self._dacs)
        
        if experiment_type == 'ADC':
            self.fpga_server.daisy_chain(list(itertools.chain(*[self._dacs,self._adcs]))) #determines which set of boards to run, not the order
            if self._adc_settings[adc_index]['RunMode']=='average':
                self.fpga_server.timing_order([self._adcs[0]])
            elif self._adc_settings[adc_index]['RunMode']=='demodulate':
                timing_order_list = ['%s::%d' %(self._adcs[0],0)] #record channel 0 fpga.timing_order(timing_order_list)
                self.fpga_server.timing_order(timing_order_list)
            else:
                raise Exception('ADC RunMode should be either ''average'' or ''demodulate'' (case sensitive).')
            ghz_fpga_control.LoadADCs(self.fpga_server, self._adcs, self._adc_settings)
        elif experiment_type == 'PreAmp':
            self.fpga_server.daisy_chain(list(itertools.chain(*[self._dacs]))) #determines which set of boards to run, not the order
            self.fpga_server.timing_order([self._dacs[0]])  
        elif experiment_type == 'MultiPreAmp':
            self.fpga_server.daisy_chain(list(itertools.chain(*[self._dacs]))) #determines which set of boards to run, not the order
            self.fpga_server.timing_order(self._dacs) 
        else:
            raise Exception("Experiment type '" + experiment_type + "' is not supported.")

        return self.fpga_server.run_sequence(reps, True)

    ###EXPERIMENT CONTROL METHODS##################################################################
    def variable(self, var, value=None, output=True):
        """
        Get or set a single variable in the experiment variables 
        dictionary. Useful if you want to run a single point experiment
        or over a few different values. 
        
        Inputs:
            var: name of the variable key in the experiment variables
                dictionary.
            value: optional parameter. If not included, the function
                returns value of an existing variable or None. 
                Otherwise, the function sets variable to a value if 
                the variable exists in among the experiment variables.
                The method raises an exception if the variable is not
                found.
        Output:
            value: value of the desired variable or None.
        """
        if value is not None:
            if var in self._vars:
                self._vars[var]['Value'] = value
                if output:
                    print("Experiment variable '" + var + 
                    "' is set to " + self.val2str(value) + ".")
            else:
                raise ExperimentDefinitionError("Variable '" + str(var) + 
                "' is not found among the experiment variables: " + 
                str(self._vars.keys()) + ".")
        else:
            if var in self._vars and 'Value' in self._vars[var]:
                return self._vars[var]['Value']
            else:
                return None

    def set_adc_setting(self, setting, value, adc_name=None):
        """
        Change one of the ADC settings.
        
        Inputs:
            adc_name: name string of the ADC. If adc_name is None and
                there is only one board in the resource dictionary,
                the board name will be automatically recognized.
            setting: name of setting you want to change.
            value: value to change the setting to.
        Output:
            None.
        """
        if adc_name is None:
            adc_name = self._get_adc_name(adc_name)
        
        if setting not in self._adc_settings[self._adcs.index(adc_name)]:
            raise ExperimentDefinitionError(str(setting) + 
            " is not a valid ADC setting name.")
        else:
            self._adc_settings[self._adcs.index(adc_name)][setting] = value
            
    def _get_adc_name(self, adc_name=None):
        """
        Check whether the ADC board with a specific name exist. If the
        input ADC board name is not specified and there is only one ADC
        board in the resource dictionary, then the name of this board is
        returned.
        
        Input: 
            adc_name (optional): the name of an ADC board.
        Output: 
            adc_name: the name of an existing ADC board (i.e. either 
                given as input adc_name or found in the resource 
                dictionary).
        """
        if adc_name is None:
            if len(self._adcs) == 1:
                adc_name = self._adcs[0]
            else:
                raise("The ADC board name should be explicitly " +
                "specified since there are more than one ADC board in " +
                "the experiment resource dictionary.")
        elif adc_name not in self._adcs:
            raise Exception("ADC board '" + str(adc_name) + 
            "' does not exist.")

        return adc_name    
    
    ###EXPERIMENT RUN FUNCTIONS####################################################################
    def set_var_request(self, var, enforce=True, value=None):
        if var not in self._vars:
            if enforce:
                raise ExperimentDefinitionError("Variable '" + str(var) + 
                "' is not defined in the resource list.")
            else:
                return
        
        if value is not None:
            self._vars['Value'] = value
        
        p = self._cxn[self._vars['Server']].packet()
        p[self._vars['Select Device']](self._vars['Address'])
        p[self._vars['Setting']](self._vars['Value'])
        self._vars['Result'] = p.send(wait=False)
        self._vars['Active'] = True
        self._vars['Save'] = True
        
    def acknowledge_request(self, var):
        if var not in self._vars:
            raise ExperimentDefinitionError("Variable '" + str(var) + 
            "' is not defined.")
        
        if self._vars['Active']:
            self._vars['Result'] = self._vars['Result'].wait()
            self._vars['Active'] = False
            return self._vars['Result'][self._vars['Setting']]

    def run_once(self):
        """
        Basic run method. In Experiment this does nothing, and should be
        what is modified in each specific inherited experiment class.
        run_once will be called by each of the sweep running methods so
        that these don't have to be redefined in each method. In the 
        inherited classes this should run one experiment (i.e. one set
        of RF/memory/SRAM commands) with the variables as currently 
        defined in the experiment variable dictionary.
        
        Input: 
            None.
        Output:
            None.
        """
        pass
        
    def run_multiple_times_then_average(self, runs):
        """
        This method is similar to run_once with the exception that 
        the experiment defined by run_once method will be called
        a specified number of times and the results of all runs will be
        averaged.
        
        Inputs: 
            runs: number of independent runs of the experiment.
        """
        self.wrap_expt_var('Runs', '', runs)
        standard_output_flag = self._standard_output
        
        for idx in range(runs):
            self.run_once()
            if idx == 0:
                if self._standard_output:
                    sys.stdout.write('Progress at current data point: 0%')
                data = {}
                for key in run_data:
                    data[key] = np.zeros((runs,) + np.shape(run_data[key]))              
            for key in data:
                data[key][idx] = run_data[key]
            self._listen_to_keyboard()
            if self._run_status== 'abort':
                if standard_output_flag:
                    sys.stdout.write(str(round(100 * (idx + 1) / float(runs), 1)) + '%\n')
                break
            if standard_output_flag:
                sys.stdout.write('.')
                if idx == runs - 1:
                    sys.stdout.write('100%\n')  

        return self._average_data(data, self._extra_data)

    def _average_data(self, data, extra_data):
        """
        Average the data returned by run_once method.

        Inputs:
            data: data dictionary.
            runs: number of independent runs of the experiment.
        """
        avg_data = {}
        for key in data:
            self.wrap_data_var(key, self.get_units(key), 'normal')
            self.wrap_data_var(key + ' Std Dev', self.get_units(key), 'std')
            avg_data[key] = np.mean(data[key], axis=0)            
            avg_data[key + ' Std Dev'] = np.std(data[key], axis=0)
        
        self.return_data(avg_data, extra_data)
   
    def single_shot_iqs(self, adc_name=None, save=False, plot_data=None):
        """
        Run a single experiment, saving individual I and Q points.
        
        Inputs:
            adc_name: the ADC board name. If the board is not specified
                and there is only one board in experiment resource 
                dictionary than it will be used by default.
            save: save the data if save is True.
            plot_data: plot the data (True by default)
        Output:
            None.
        """
        adc_name = self._get_adc_name(adc_name)
        previous_adc_mode = self._adc_settings[self._adcs.index(adc_name)]['RunMode']
        self._adc_settings[self._adcs.index(adc_name)]['RunMode'] = 'demodulate'
            
        self.run_once()
        
        self._adc_settings[self._adcs.index(adc_name)]['RunMode'] = previous_adc_mode
        
        if plot_data is not None:
            plt.ion()
            plt.figure(13)
            plt.plot(run_data['Single Shot Is'], run_data['Single Shot Qs'], 'b.')
            plt.xlabel('I [ADC units]')
            plt.ylabel('Q [ADC units]')
            plt.title('Single Shot Is and Qs')
            plt.draw()

        if save:        # Save the data.
            self._save_data(self._extra_data['Indep Names'], self._extra_data['Indep Values'], run_data, self._extra_data['dependencies'])

    def single_shot_osc(self, adc_name=None, save=False, plot_data=None):
        """
        Run a single shot experiment in average mode, and save the 
        time-demodulated data to file.
        
        Inputs: 
            adc_name: the ADC board name. If the board is not specified
                and there is only one board in experiment resource
                dictionary than it will be used by default.
            save: save the data if save is True.
            plot_data: data variables to plot.
        Output:
            None.
        """
        self.avg_osc(adc_name, save, plot_data, runs=1)

    def avg_osc(self, adc_name=None, save=False, plot_data=None, runs=100):
        '''
        Run a single experiment in average mode Reps number of times 
        and average the results together.
        
        Inputs:
            adc_name: ADC board name.
            save: save the data to disk.
            plot_data: data variables to plot.
            runs: number of runs (100 by default).
        Output:
            None.
        '''
        print('\nCollecting the ADC data...\n')
              
        self._run_status= ''
        self._run_message = ''
        
        adc_name = self._get_adc_name(adc_name)
        previous_adc_mode = self._adc_settings[self._adcs.index(adc_name)]['RunMode']
        self._adc_settings[self._adcs.index(adc_name)]['RunMode'] = 'average'
        
        self.run_once()
        data = run_data.copy()
        
        if plot_data is not None:        # Make a list of data variables that should be plotted.
            for var in self._combine_strs(plot_data):
                if var not in data:
                    print("Warning: key '" + var + 
                    "' does not exist in the data dictionary: " + 
                    str(run_data) + ".")
            plot_data = [var for var in self._combine_strs(plot_data) if var in data]
        if plot_data:
            self._init_1d_plot(self._extra_data['Indep Values'][0][0], 
                data, self._extra_data['Indep Names'][0][0], plot_data)

        if runs > 1:        # Run multiple measurement shots.
            print('\t[ESC]:\tAbort the run.' + 
                  '\n\t[S]:\tAbort the run but [s]ave the data.\n')
            sys.stdout.write('Progress: 0%')
            self.add_expt_var('Runs', runs)
            stepsize = max(int(round(runs / 25)), 1)
            plot_data = run_data
            for r in range(runs - 1):
                self._listen_to_keyboard(recog_keys=[27, 83, 115], clear_buffer=False)  # Check if the specified keys are pressed.
                if self._run_statusin ['abort', 'abort-and-save']:
                    self._vars['Runs']['Value'] = r + 1
                    sys.stdout.write(str(round(100 * self._vars['Runs']['Value'] / float(runs), 1)) + '%\n')
                    print(self._run_message)
                    break  
                self.run_once()
                for key in data:    # Accumulate the data values. These values should be divided by the actual number of Reps to get the average values.
                    data[key] = data[key] + run_data[key]
                if np.mod(r, stepsize) == 0:
                    sys.stdout.write('.')
                    if plot_data:
                        for key in plot_data:
                            plot_data[key] = run_data[key] / float(r + 1)
                        self._update_1d_plot(self._extra_data['Indep Values'][0][0], plot_data, self._extra_data['Indep Names'][0][0], plot_data)
                if r == runs - 2:
                    sys.stdout.write('100%\n')
            for key in data:
                data[key] = data[key] / float(runs)
        
        if plot_data:        # Save the data.
            self._update_1d_plot(self._extra_data['Indep Values'][0][0], run_data, self._extra_data['Indep Names'][0][0], plot_data)
        
        self._adc_settings[self._adcs.index(adc_name)]['RunMode'] = previous_adc_mode
        
        if (save and self._run_status!= 'abort') or self._run_status== 'abort-and-save':        # save data.
            self._save_data(self._extra_data['Indep Names'], self._extra_data['Indep Values'], run_data, self._extra_data['dependencies'])

    def _process_data(self, raw_data):
        """
        Check that the data dictionary returned by a single run of
        an experiment meets minimum consistency criteria. Restore
        the field entries that are omitted.
        
        Input:
            raw_data: data dictionary returned, for example, by run_once
                method.
        Output:
            data: processed data dictionary potentially with some
                restored fields.
        """
        # Assign 'Type' to be 'Independent' if the variable
        # is listed in any dependency specifications.
        data = {}
        for key in raw_data:
            data[key] = raw_data[key].copy()
            if 'Dependencies' in data[key]:
                for dep in data[key]['Dependencies']:
                    if dep not in data:
                        raise DataError("Data variable '" + str(key) + 
                        "' dependencies should be specified as a string" +
                        " or a list of strings.")
                    if 'Value' not in data[dep]:
                        raise DataError("Independent data variable '" + 
                        str(dep) + "' does not have 'Value' entry.")
                    if 'Type' in dep:
                        if 'Type' != 'Independent':
                            raise DataError("Conflicted dependencies " +
                            "are specified in the '" + str(key) + 
                            "' and '" + str(dep) + "' data entries.")
                    else:
                        data[dep]['Type'] = 'Independent'
        
        # Check that data variables containing more than one element
        # have their dependencies properly specified.
        for key in data:
            if 'Value' in data[key] and ('Type' not in data[key] or
                    data[key]['Type'] == 'Dependent'):
                if (isinstance(data[key]['Value'], np.ndarray)
                    and data[key]['Value'].size > 1):
                    if 'Dependencies' not in data[key]:
                        raise DataError("Data variable '" + str(key) + 
                        "' is returned without a dependency specification.")
                    elif isinstance(data[key]['Dependencies'], str):
                        data[key]['Dependencies'] = [data[key]['Dependencies']]
                    elif isinstance(data[key]['Dependencies'], list):
                        if not all([isinstance(name, str) for name in 
                                data[key]['Dependencies']]):
                            raise DataError("Data variable '" + str(key) + 
                            "' dependencies should be specified as a string" +
                            " or a list of strings.")
                    expected_shape = ()
                    for dep in data[key]['Dependencies']:
                        expected_shape = expected_shape + np.shape(data[dep]['Value'])
                    if np.shape(data[key]['Value']) != expected_shape:
                        raise DataError("Data variable '" + str(key) + 
                        "' shape does not match the size of the " +
                        "independent variables.")
                elif 'Dependencies' not in data[key]:
                    data[key]['Dependencies'] = []
                elif len(data[key]['Dependencies']) > 0:
                    raise DataError("Data variable '" + str(key) + 
                        "' is not a numpy array with more than one " +
                        "element and, thus, should not have any " +
                        "dependencies explicitly specified.")
        
        # Ensure that the types are assigned correctly.
        for key in data:
            if 'Type' not in data[key]:
                data[key]['Type'] = 'Dependent'
            elif data[key]['Type'] not in ['Dependent', 'Independent']:
                raise DataError("The data entry 'Type' should " +
                "be either 'Dependent' or 'Independent'.")

        return data
            
    def _sweep(self, names, values, 
            print_expt_vars=None, print_data_vars=None, 
            plot_data_vars=None, max_data_dim=2, runs=1):
        """
        Run an N-dimensional sweep over a given set of variables. In the
        most general case names and values should be list of lists of 
        strings and 1D numpy arrays of the same structure. The 
        experiment and data variables that should printed and/or plotted
        should be specified when necessary.
        
        Inputs:
            names: names of the variable over which to sweep.
            values: values over which the sweep the variables.
            save: the data will be saved if this flag is True.
            print_data_vars (optional): data variables to print to the 
                standard output as a list of strings (or a string).
            plot_data_vars (optional): data variables to plot as a list
                of strings (or a string).
            max_data_dim (optional): limit on the maximum dimension of 
                the data array. This prevents saving unnecessary large
                data sets when it is not required.
            runs (optional): number of experiment runs at each point, 
                the output data will be averaged.
        Output:
            None.
        """
        if len(names[0]) == 1:      # Run a 1D sweep.
            for idx in range(values[0][0].size):
                for p_idx in range(len(names)):
                    self.variable(names[p_idx][0], values[p_idx][0][idx], False)

                if runs == 1:
                    # Run the experiment once.
                    run_data = self.run_once()
                else:
                    # Run the same experiment multiple times.
                    run_data = self.run_multiple_times_then_average(runs)
                
                self._sweep_pts_acquired = self._sweep_pts_acquired + 1 

                if idx == 0:
                    # Initialize the data dictionary.
                    # Check that the dictionary is properly defined.
                    data = self._process_data(run_data)
                    # Preallocate the memory resources.
                    for key in data:
                        if 'Value' in data[key]:
                            entry_shape = np.shape(values[0][0]) + np.shape(data[key]['Value'])
                            if len(entry_shape) <= max_data_dim:
                                data[key]['Value'] = np.empty(entry_shape)
                            else:
                                data[key]['Value'] = np.empty(entry_shape)

                    # Make a list of the sweep variables that should be 
                    # printed to the standard output.
                    for var in self._combine_strs(print_expt_vars):
                        if var not in self._vars:
                            print("Warning: variable '" + str(var) + 
                            "' is not found among the experiment variables: " + 
                            str([var for var in self._vars]) + 
                            ". The value of this variable will not be printed.")
                    print_expt_vars = [var for var in self._combine_strs(print_expt_vars) if var in self._vars]

                    # Make a list of the data variables that should be
                    # printed to the standard output.
                    if print_data_vars is None:
                        print_data_vars = [var for var in run_data if np.size(run_data[var]['Value']) == 1]
                    else:
                        for var in self._combine_strs(print_data_vars):
                            if var not in run_data:
                                print("Warning: key '" + str(var) +
                                "' has not been found in the data dictionary: " +
                                str(run_data) + ". This data will not be printed.")
                        print_data_vars = [var for var in self._combine_strs(print_data_vars) if var in run_data and np.size(run_data[var]) == 1]
                        
                    plot_data_vars = self._init_1d_plot(values, data, names, plot_data_vars)

                # Add the newly acquired data to the data set.
                for key in data:
                    if 'Value' in data[key]:
                        data[key]['Value'][idx] = run_data[key]['Value']
                
                # Print experiment and data variables to the standard output.
                if self._standard_output and self._run_status!= 'abort':
                    for var in print_expt_vars:
                        print(var + ' = ' + self.val2str(self._vars[var]['Value']))
                    for var in print_data_vars:
                        print(var + ' = ' + self.val2str(run_data[var]['Value']))
                
                 # Update the plot when it makes sense to do so.
                if plot_data_vars is not None and idx > 0:
                    if SameXAxis:
                        self._update_1d_plot(values[0][0][:idx+1], data,
                            names[0][0], plot_data_vars)
                    elif SimilarXAxes:
                        self._update_1d_plot(values[0][0][:idx+1], data,
                            [nm[0] for nm in names], plot_data_vars)
                    else:
                        self._update_1d_plot(np.array(range(idx + 1)), data,
                            'Run Iteration (along Fast Axis)', plot_data_vars)

                if self._run_status == '':
                    # Check whether any key is pressed.
                    self._listen_to_keyboard()
                if self._run_message != '':
                    print(self._run_message)
                    self._run_message = ''
                if self._run_status == 'abort':
                    break
                elif self._run_status == 'abort-and-save':
                    # The scan has been aborted.
                    # Delete unused sweep variable values.
                    for p_idx in range(len(values)):
                        values[p_idx] = [np.delete(values[p_idx][0], np.s_[idx+1:], None)]
                    # Delete unfilled data points since the data 
                    # has been previously initialize with np.empty.
                    for key in data:
                        if 'Value' in data[key]:
                            data[key]['Value'] = np.delete(data[key]['Value'], np.s_[idx+1:], 0)
                    break

            return data, values
        else:   # Recurrent implementation of the multidimensional sweeps.
            run_names = []
            run_vals = []
            for p_idx in range(len(names)):
                run_names.append(names[p_idx][1:])
                run_vals.append(values[p_idx][1:])
                
            for idx0 in range(values[0][0].size):
                # Assign new values for the sweep variables.
                for p_idx in range(len(names)):
                    self.variable(names[p_idx][0], values[p_idx][0][idx0], False)
                run_data, vals = self._sweep(run_names, run_vals, 
                        print_expt_vars, print_data_vars, 
                        plot_data_vars, max_data_dim, runs)
                
                if idx0 == 0:
                    # Initialize data dictionary.
                    data = run_data.copy()
                    for key in data:
                        if 'Value' in data[key]:
                            entry_shape = np.shape(values[0][0]) + np.shape(data[key])
                            if len(data_entry_shape) <= max_data_dim:
                                data[key]['Value'] = np.empty(entry_shape)
                
                if self._run_status == 'abort-and-save':
                    if idx0 == 0:
                        # The experiment was aborted during 
                        # the acquisition of the first slice.
                        for p_idx in range(len(values)):
                            values[p_idx] = [np.array([values[p_idx][0][0]])] + vals[p_idx]
                        data = run_data
                    elif np.shape(vals[0][0]) == np.shape(values[0][1]):
                        # A full data slice has been acquired.
                        for p_idx in range(len(values)):
                            values[p_idx] = [np.delete(values[p_idx][0], np.s_[idx0+1:], None)] + values[p_idx][1:]
                        for key in data:
                            if 'Value' in data[key]:
                                data[key]['Value'][idx0] = run_data[key]['Value']
                                data[key]['Value'] = np.delete(data[key]['Value'], np.s_[idx0+1:], 0)
                    else:
                        # The current slice hasn't been fully acquired.
                        for p_idx in range(len(values)):
                            values[p_idx] = [np.delete(values[p_idx][0], np.s_[idx0:], None)] + values[p_idx][1:]
                        for key in data:
                            if 'Value' in data[key]:
                                data[key]['Value'] = np.delete(data[key]['Value'], np.s_[idx0:], 0)
                    break
                elif self._run_status == 'abort':
                    break
                
                # Add the newly acquired data to the data set.
                for key in data:
                    if 'Value' in data[key]:
                        data[key][idx0] = run_data[key]

            return data, values

    def sweep(self, names, values, save=False, 
            print_data=None, plot_data=None, 
            dependencies=None, max_data_dim=2, runs=1):
        """
        Run an N-dimensional sweep over a given set of variables, 
        defined by the keys in the experiment variable dictionary.
        In the most general case names and values should be list of
        lists of strings and 1D numpy arrays. The data will be saved
        with some non-public methods if save flag is True.
        The experiment and data variables that should printed and/or
        plotted could be specified when necessary.
        
        Inputs:
            names: names of the variable over which to sweep.
            values: values over which the sweep the variables.
            save: the data will be saved if this flag is True.
            print_data (optional): data variables to print to 
                the standard output as a list of strings (or a string).
            plot_data (optional): data variables to plot as a list
                of strings (or a string).
            dependencies (optional): dependency specifications.
            max_data_dim (optional): limit on the maximum dimension
                of the data array. This prevents saving unnecessary
                large data sets when it is not required.
            runs (optional): number of the experiment runs at each
                point, the output data will be averaged (using 
                _average_data method).
        Output:
            None.
        
        Examples:
            run.sweep([['RF Frequency'], ['RF Frequency']],
                      [[np.array([1e9, 2e9, 3e9] * GHz)], 
                       [np.array([1e9, 2e9, 3e9] * Ghz)]], 
                      save=True, print_data=['Pa', 'Pb'],
                      plot_data=['Pa', 'Pb'], 
                      dependencies=[['Pa'], ['Pb']])
                 
            run.sweep([['x'], ['y']], [[xval], [yval]], save=True,
                      print_data=['Result 1', 'Result 2'], 
                      plot_data=['Result 1', 'Result 2'])
        """
        if not hasattr(self, '_vars'):
            raise Exception('Experiment resources and variables should' + 
            ' be set prior attempting any scans.')

        excpt_msg = ('The first argument in sweep method should be'
        ' either a string (for a 1D simple scan), a list of strings'
        ' (for a multidimensional scan), or a list of lists of strings'
        ' (for a parallel any-dimensional scan).')
        
        if isinstance(names, str):
            # Check that the variable is properly defined.
            self._check_var(names)
            # If there is only one sweep variable defined as a string,
            # convert it to a list of lists for internal code consistency.
            names = [[names]]
        elif isinstance(names, list):
            # Check that there are more than zero elements and confirm 
            # that they are strings.
            if len(names) > 0 and isinstance(names[0], str):
                for name in names:
                    self._check_var(name)
                # Check that the variables are unique.
                if len(names) > len(set(names)):
                    raise SweepError('Sweep method was called with ' +
                    'repeated variable names. The data might be hard ' +
                    'to interpret.')
                # If there are no independent parallel scans, convert 
                # the list to a list of lists for internal code consistency.
                names = [names]
            elif (len(names) > 0 and isinstance(names[0], list) 
                  and len(names[0]) > 0):
                # Do the following checks if a list of lists of strings 
                # is actually specified.
                for name_list in names:
                    # Check that all nested elements are lists.
                    if not isinstance(name_list, list):
                        raise SweepError(excpt_msg)
                    # Check that the nested lists have the same length.
                    if len(name_list) != len(names[0]):
                        raise SweepError('The length of name lists ' +
                        'should be the same for any parrallel scans.') 
                    # Check that the variables are properly defined.
                    for name in name_list:
                        self._check_var(name)
                    # Check that the variables are unique.
                    if len(name_list) > len(set(name_list)):
                        raise SweepError('sweep method was called with' + 
                        ' repeated variable names.')
                # Check that there are no repeated variable names along
                # different scan axes.
                for list_idx1, name_list1 in enumerate(names):
                    for name_idx1, name1 in enumerate(name_list1):
                        for name_list2 in names[list_idx1+1:]:
                            for name_idx2, name2 in enumerate(name_list2):
                                # Repeated variable names along the same 
                                # axis are allowed!
                                if name_idx1 != name_idx2 and name1 == name2:
                                    raise SweepError('Sweep method was' + 
                                    ' called with repeated variable' +
                                    ' names along differenent scan axes.')
            else:
                raise SweepError(excpt_msg)
        else:
            raise SweepError(excpt_msg)
        
        excpt_msg = ('The second argument in sweep method should be'
        ' either a 1D numpy array (for a 1D simple scan), a list of 1D'
        ' numpy arrays (for a multidimensional scan) or a list of lists'
        ' of 1D numpy arrays (for a parallel any-dinesional scan). For'
        ' parallel scans, the length of the 1D numpy arrays should be'
        ' equal along the same scan axis. Each numpy array should'
        ' contain at least one number.')
        if isinstance(values, np.ndarray):
            # Check the number of dimensions.
            if np.ndim(values) != 1:
                raise SweepError(excpt_msg)
            # If there is only one sweep variable defined as a 1D numpy 
            # array, convert it to a list of lists for internal code
            # consistency.
            values = [[values]]
        elif isinstance(values, list):
            if len(values) > 0 and isinstance(values[0], np.ndarray):
                for value in values:            
                    # Check the type and number of the dimensions.
                    if (not isinstance(values[0], np.ndarray) or 
                        np.ndim(value) != 1):
                        raise SweepError(excpt_msg)
                # If there are no independent parallel scans, convert
                # the list of 1D numpy arrays to a list of lists for 
                # internal code consistency.
                values = [values]
            elif (len(values) > 0 and isinstance(values[0], list) and
                  len(values[0]) > 0):
                # Do the following checks if a list of lists of 1D numpy
                # arrays is actually specified.
                for value_list in values:
                    # Check that all nested elements are lists.
                    if not isinstance(value_list, list):
                        raise SweepError(excpt_msg)
                    # Check that the nested lists have the same length.
                    if len(value_list) != len(values[0]):
                        raise SweepError('The length of 1D numpy array' + 
                        ' lists should be the same for each parrallel scan.')
                    # Check that all sub-nested elements are non-empty
                    # 1D numpy arrays.
                    for value in value_list:
                        if (not isinstance(value, np.ndarray) or 
                            np.ndim(value) != 1 or np.size(value) == 0):
                            raise SweepError(excpt_msg)
                # Check that numpy arrays have the same length along
                # the same scan axis.
                for list_idx, value_list in enumerate(values):
                    for value_idx, value in enumerate(value_list):
                        if (len(values[0]) <= value_idx or
                            (list_idx > 0 and
                             values[0][value_idx].size != value.size)):
                            raise SweepError(excpt_msg)
            else:
                raise SweepError(excpt_msg)
        else:
            raise SweepError(excpt_msg)
        
        # Check that the sweep variables (names) and values can be
        # directly mapped to each other.
        if len(names) != len(values):
            raise SweepError('Sweep method was called with variable' +
            ' names that specified in a way could not be' +
            ' unambigiously matched to the values.')
        for list_idx, name_list in enumerate(names):
            if len(name_list) != len(values[list_idx]):
                raise SweepError('Sweep variables could not' +
                ' be unambigiously matched to their values.')
        
        # Prevent any attempts to set any sweep variable twice to some
        # different values. If this is allowed, it would be really hard
        # to interpret the data.
        for list_idx1, name_list1 in enumerate(names):
            for name_idx1, name1 in enumerate(name_list1):
                for list_idx2, name_list2 in enumerate(names):
                    if (list_idx2 > list_idx1 and
                        name1 == name_list2[name_idx1] and 
                        (values[list_idx1][name_idx1] != 
                         values[list_idx2][name_idx1]).any()):
                        raise SweepError('Sweep method was called with' +
                        ' repeated variable names along some scan axis' +
                        ' but the 1D numpy value arrays corresponding' +
                        ' to these variables are not the same.')
        
        excpt_msg = ('Optional parameter dependencies in sweep ' +
        'method should be either a string (for a 1D simple scan), '
        'a list of strings (for a single multidimensional scan), or a list' +
        ' of lists of strings (for parallel any-dimensional scans).')
        # If any dependencies are specified, check the following.
        if dependencies is not None:
            # If there is only one dependency is specified, convert it
            # to a list of lists for internal code consistency.
            if isinstance(dependencies, str):
                dependencies = [[dependencies]]
            elif isinstance(dependencies, list):
                # If only a simple list is specified, convert this list
                # of strings to a list of lists for internal code 
                # consistency.
                if len(dependencies) > 0 and isinstance(dependencies[0], str):
                    # Check that all nested elements are strings.
                    if any([not isinstance(dep, str) for dep in dependencies]):
                        raise SweepError(excpt_msg)
                    dependencies = [list(set(dependencies))]
                elif len(dependencies) > 0 and isinstance(dependencies[0], list):
                    for list_idx, dep_list in enumerate(dependencies):
                        # Check that all nested elements are lists.
                        if not isinstance(dep_list, list):
                            raise SweepError(excpt_msg)
                        # Check that all sub-nested elements are strings.
                        if any([not isinstance(dep, str) for dep in dep_list]):
                            raise SweepError(excpt_msg)
                        dependencies[list_idx] = list(set(dep_list))
                    for list_idx, dep_list1 in enumerate(dependencies):
                        # Check that the same data variable does not 
                        # have any duplicated dependency specifications.
                        for dep1 in dep_list1:
                            for dep_list2 in dependencies[list_idx+1:]:
                                for dep2 in dep_list2:
                                    if dep1 == dep2:
                                        raise SweepError('Sweep method' +
                                        ' was called with conflicted' +
                                        ' dependency specifications.')
                else:
                    raise SweepError(excpt_msg)
            else:
                raise SweepError(excpt_msg)
            # Check that the sweep variables (names) and dependencies 
            # can be directly mapped to each other.
            if len(dependencies) != len(names):
                raise SweepError('Dependency specifications could not be' +
                ' unambigiously matched to sweep variables.')

        self._run_status= ''            # E.g. 'abort' or 'abort-and-save'.
        self._run_message = '';
        self._sweep_dimension = len(names[0])   # Dimension of the sweep.
        self._sweep_start_time = time.time()    # Start time for the finish time estimation.
        self._sweep_number_of_pts = 1   # Total number of measurement points.
        for val in values[0]:
            self._sweep_number_of_pts = len(val) * self._sweep_number_of_pts
        self._sweep_pts_acquired = 0    # Number of the acquired data points.

        print('\nStarting a ' + str(self._sweep_dimension) + 
              'D data sweep...\n' + 
              '\n\t[ESC]:\tAbort the run.' + 
              '\n\t[S]:\tAbort the run but [s]ave the data.' +
              '\n\t[T]:\tEstimate the finish [t]ime for the current scan.' +
              '\n\t[O]:\tTurn [o]n/[o]ff data printing to the standard [o]utput.' + 
              '\n\t[X]:\tSecret option.\n')
        
        print_expt_vars = []
        for name_list in names:
            print_expt_vars = print_expt_vars + name_list

        data, values = self._sweep(names, values, print_expt_vars,
                print_data, plot_data, max_data_dim, runs)

        if ((save and self._run_status!= 'abort') or
            self._run_status == 'abort-and-save'):
            # If there is at least one point to save then...
            if values[0][0].size > 0:
                # Fully specify dependencies of
                # the data variables on the sweep variables.
                # This simplifies work-flow when several
                # independent measurements that are done in parallel.
                if dependencies is None and len(names) == 1:
                    dependencies = [[key for key in data 
                            if 'Type' in data[key]
                            and data[key]['Type'] == 'Independent']]
                if dependencies is not None:
                    for list_idx, dep_list in enumerate(dependencies):
                        for dep in dep_list:
                            if dep in data:
                                data[dep]['Dependencies'] = (names[list_idx] + 
                                        data[dep]['Dependencies'])
                            else:
                                print("Warning: data variable '" + 
                                str(dep) + "' that is given in the " + 
                                "dependency list is not found in the " +
                                "data dictionary. This dependency " +
                                "specification will be ignored.") 
                # Add the dependency specifications to the run_once
                # data that are not single numbers.
                for list_idx, name_list in enumerate(names):
                    for name_idx, name in enumerate(name_list):
                        data[name] = {'Value': values[list_idx][name_idx],
                                      'Type': 'Independent'}
                # Save the data.
                self._save_data(data)
            else:
                print('There is no data to save!')
 
    ###KEYBOARD LISTENERS##########################################################################
    def _listen_to_keyboard(self, 
            recog_keys=[27, 83, 115, 84, 116, 79, 111, 88, 120],
            clear_buffer=True):
        if kbhit():
            # Analyze the first character in the keyboard buffer.
            key = getch()
            if ord(key) in recog_keys:
                if ord(key) == 27:
                    # [ESC] is pressed.
                    self._run_status= 'abort'
                    self._run_message = 'The experiment has been aborted!'
                elif ord(key) == 83 or ord(key) == 115:
                    # Either [S] or [s] is pressed.
                    self._run_status= 'abort-and-save'
                    self._run_message = 'The experiment has been aborted!'
                elif ord(key) == 84 or ord(key) == 116:
                    # Either [T] or [t] is pressed.
                    if self._sweep_pts_acquired > 0:
                        finish_time = time.localtime(self._sweep_start_time + 
                                      self._sweep_number_of_pts * 
                                      (time.time() - self._sweep_start_time) /
                                      self._sweep_pts_acquired)
                        self._run_message = ('The estimated finish time is ' + 
                        time.strftime("%H:%M:%S", finish_time) + ' on ' + 
                        time.strftime("%m/%d/%Y", finish_time) + '.')
                    else:
                        self._run_message = ('No data has been acquired ' +
                        ' yet to allow any time estimation.')
                elif ord(key) == 79 or ord(key) == 111:
                    # Either [O] or [o] is pressed.
                     self._standard_output = not self._standard_output
                elif ord(key) == 88 or ord(key) == 120:
                    # Either [X] or [x] is pressed.
                     self._run_message = 'Hey, stop wondering! Get back to work!'
        
        # Clear the keyboard buffer if requested.
        if clear_buffer:
            while kbhit():
                getch()

    ###PLOTTING METHODS############################################################################
    def _init_1d_plot(self, values, data, names, plot_data_vars):  
        # Make a list of the data variables that should be plotted.
        if plot_data_vars is not None:
            for var in self._combine_strs(plot_data_vars):
                if var not in data:
                    print("Warning: key '" + var + 
                    "' has not been found in the data dictionary: " + 
                    str(run_data) + ". This data will not be plotted.")
            plot_data_vars = [var for var in self._combine_strs(plot_data_vars) 
                    if var in data and 
                    np.size(data[var]['Value']) == 1]
            # Determine the X axis label.
            if plot_data_vars and values[0][0].size > 1:
                SameXAxis = True
                SimilarXAxes = True
                for p_idx in range(len(names)):
                    if names[p_idx][0] != names[0][0]:
                        SameXAxis = False
                    if ((values[p_idx][0] != values[0][0]).any() or 
                        self.get_units(names[p_idx][0]) != self.get_units(names[0][0])):
                        SimilarXAxes = False
                    if SameXAxis == False and SimilarXAxes == False:
                        break
                if SameXAxis:
                    self._create_1d_plot(values[0][0], data,
                        names[0][0], plot_data_vars)
                elif SimilarXAxes:
                    self._create_1d_plot(values[0][0], data,
                        [nm[0] for nm in names], plot_data_vars)
                else:
                    self._create_1d_plot(np.array(range(values[0][0].size)),
                        data, 'Run Iteration (along Fast Axis)', plot_data_vars)
            else:
                plot_data_vars = None  
            
        return plot_data_vars

    def _create_1d_plot(self, values, data, independent_vars, plot_data_vars):
        # Specify x-axis label.
        xlabel = ''
        for var in self._combine_strs(independent_vars):
            xlabel = xlabel + var + self.get_units(var, True) + ', '
        xlabel = xlabel[:-2]
        
        # Specify y-axis label.
        ylabel = ''
        for var in plot_data_vars:
            if 'name' in data[var]['Preferences']:
                var = data[var]['name']
            ylabel = ylabel + var + self.get_units(data[var]['Value'], True) + ', '
        ylabel = ylabel[:-2]
        
        # Initialize the plot.
        plt.figure(1)
        plt.ion()
        plt.clf()
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        
        # Specify line styles.
        self.plot_lines = {}
        for var in plot_data_vars:
            # Default line styles and plot parameters. Predefining helps
            # make the code below a bit shorter and can potentially
            # reduce severity of the bugs here.
            linestyle = 'b-'
            linewidth = 2
            linelabel = var
            # Redefine any plot parameters that are actually specified.
            if var in data and 'Preferences' in data[var]:
                if 'linestyle' in data[var]['Preferences']:
                    linestyle = data[var]['Preferences']['linestyle']
                if 'linewidth' in data[var]['Preferences']:
                    linewidth = data[var]['Preferences']['linewidth']
                if 'legendlabel' in data[var]['Preferences']:
                    linelabel = data[var]['Preferences']['legendlabel']
            self.plot_lines[var], = plt.plot(values, np.zeros_like(values), 
                linestyle, lw=linewidth, label=linelabel)
        if len(plot_data_vars) > 1:
            plt.legend() 
        
        # Specify axes limits.
        plt.xlim(min(values[0], values[1]), max(values[0], values[1]))  
        self.plot_ymin = None
        self.plot_ymax = None
        for var in plot_data_vars:
            if (var in data and 'Preferences' in data[var] and
               'ylim' in data[var]['Preferences']):
                if data[var]['Preferences']['ylim'][0] is not None:
                    if self.plot_ymin is not None:
                        self.plot_ymin = np.min([self.plot_ymin,
                            data[var]['Preferences']['ylim'][0]])
                    else:
                        self.plot_ymin = data[var]['ylim'][0]
                if data[var]['ylim'][1] is not None:
                    if self.plot_ymax is not None:    
                        self.plot_ymax = np.max([self.plot_ymax,
                            data[var]['Preferences']['ylim'][1]])
                    else:
                        self.plot_ymax = data[var]['Preferences']['ylim'][1]
        if self.plot_ymin is not None and self.plot_ymax is not None:
            plt.ylim(self.plot_ymin, self.plot_ymax)
        
    def _update_1d_plot(self, values, data, independent_vars, 
            plot_data_vars):
        plt.figure(1)
        
        # Set data.
        for var in plot_data_vars:
            self.plot_lines[var].set_ydata(data[var])
        
        # Specify axes limits.
        plt.xlim(min(values), max(values))
        if self.plot_ymax is None:
            ymax = np.max([np.max(data[var][0:len(values)]) for var in plot_data_vars])
        else:
            ymax = self.plot_ymax
        if self.plot_ymin is None:
            ymin = np.min([np.min(data[var][0:len(values)]) for var in plot_data_vars])
        else:
            ymin = self.plot_ymin
        if ymin == ymax:
            ymax = ymax + np.finfo(type(ymax)).eps
        plt.ylim(ymin, ymax)
        
        # Redraw.
        plt.draw()
        plt.pause(0.05)

    def _plot_waveforms(self, values, colors, labels):
        if not isinstance(values, list):
            values = [values]
        if not isinstance(colors, list):
            colors = [colors]
        if not isinstance(labels, list):
            labels = [lables]
        if not len(values) == len(colors) == len(labels):
            return
        time = np.linspace(0, values[0].size - 1, values[0].size)
        plt.figure(2)
        plt.ion()
        plt.clf()
        for idx, val in enumerate(values):
            plt.plot(time, val, colors[idx], label=labels[idx])
        plt.xlim(time[0], time[-1])
        plt.legend()
        plt.xlabel('Time [ns]')
        plt.ylabel('DAC Waveforms [DAC units]')
        plt.draw()
        
    def _plot_histogram(self, data, number_of_devices=1, 
            pream_timeout=1253):
        if number_of_devices == 0:
            return
        data = np.array(data)
        plt.figure(3)
        plt.ion()
        plt.clf()
        if number_of_devices == 1: 
            plt.hist(data[0, :], bins=500, range=(0, pream_timeout),
                color='b')
        elif number_of_devices == 2:
            plt.hist(data[0, :], bins=500, range=(0, pream_timeout),
                color='b', label='JPM A')
            plt.hist(data[1, :], bins=500, range=(0, pream_timeout),
                color='r', label='JPM B')
            plt.legend()
        elif number_of_devices > 2:
            raise Exception('Histogram plotting for more than two ' +
            'devices is not implemented.')
        plt.xlabel('Timing Information [counts]')
        plt.ylabel('Counts')
        plt.draw()