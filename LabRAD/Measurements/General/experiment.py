# Copyright (C) 2015 Guilhem Ribeill, Ivan Pechenezhskiy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
Base class for all python-based LabRAD experiments. This class should be the parent class for a particular experiment.
It provides shared functionality for setting experiment variables, electronics initialization, running single point experiments
as well as 1D and 2D sweeps, and saving data to text and MATLAB .mat files. Particular experiments should be generated by using 
this as a parent class.

A basic experiment program would look something like this:

with SomeExperiment.Experiment() as expt:    
    expt.set_experiment(experiment_information, resources, experimet_variables) 
    freq = np.linspace(2e9, 5e9, 101) * GHz
    expt.sweep('RF Frequency', freq, save=True)
"""

import os
if __file__ in [f for f in os.listdir('.') if os.path.isfile(f)]:
    SCRIPT_PATH = os.path.dirname(os.getcwd())  # This will be executed when the script is loaded by the labradnode.
else:
    SCRIPT_PATH = os.path.dirname(__file__)     # This will be executed if the script is started by clicking or in a command line.
LABRAD_PATH = os.path.join(SCRIPT_PATH.rsplit('LabRAD', 1)[0])
import sys
if LABRAD_PATH not in sys.path:
    sys.path.append(LABRAD_PATH)

import time
import warnings
import itertools
from msvcrt import kbhit, getch

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cbook
warnings.filterwarnings("ignore", category=matplotlib.cbook.mplDeprecation)
import scipy.io as sio

import labrad

import LabRAD.Servers.GHzBoards.ghz_fpga_control as DAC

class ExperimentDefinitionError(Exception): pass
class SweepError(Exception): pass

class Experiment:
"""
Experiment class. Parent class for specific instances of experiments that provides shared functionality
"""   
    def __init__(self):
        """
        Inputs:
            None.
        Outputs:
            None.
        """ 
        self._cxn = labrad.connect()
        self._StandardOutputFlag = True      # This flag controls the standard output of the experiment results upon pressing [O].

    def __del__(self):
        '''
        Just in case...
        '''
        plt.close('all')
        
    def __enter__(self):
        '''
        Context entry. For now all it does is return a copy of the initialized class
        '''
        return self
    
    def __exit__(self,type, value, traceback):
        """
        Safely close all connections, close plots, and disconnect from LabRad. Could also catch exceptions here if needed
        """
        self.cxn.disconnect()
        print('The instrument resources have been safely terminated! Have a nice day.')
  
    ###SETUP METHODS#####################################################################################
    ##################################################################################################### 
    def SetExperiment(self, experiment_information, resources, experimet_variables)
        """
        Sets experiment information, resources and experiment variables.
        
        Inputs:
            experiment_information: dictionary that should have the following parameters (as strings):
                1. Device Name: Name of the resource under study
                2. User: Who is running the experiment?
                3. Base Path: initial path for data saving purposes.
                4. Experiment Name: what are you doing?
                5. Comments: any comments that will go in the header file of each saved data file (optional, will be blank if not included).
            experiment_resources: list of resources in the following format:
              [ { # Generic device
                    'Resource': 'device name'
                    'Server': 'server name',
                    'Address': 'address that could be used to select the device',
                    'Variables': {
                                    'Variable 1': 'server setting that controls Variable 1', 
                                    'Variable 2': 'server setting that controls Variable 2'
                                 }
                },
                { # Waveform parameters.
                    'Resource': 'GHz Boards', 
                    'Server': 'GHz FPGAs'
                    'Variables': ['Pulse 1 Duration', 'Pulse 2 Duration']
                },
                { # DACs are converted to a simple ordered list internally based on 'List Index' value.
                    'Resource': 'DAC',
                    'DAC Name': 'Board DAC 1',
                    'List Index': 0,
                    'DAC Settings': {
                                        'DAC A': 'RF I',
                                        'DAC B': 'RF Q',
                                        'FO1 FastBias Firmware Version': '2.1'
                                    },
                    'Variables': []
                },
                { # ADCs are converted to a simple ordered list internally based on 'List Index' value.  
                    'Resource': 'ADC',
                    'ADC Name': 'Board ADC 3',
                    'List Index': 0,
                    'ADC Settings': { # These default settings might be over-written by the Experiment methods. 
                                        'RunMode': 'demodulate', #'average'
                                        'FilterType': 'square',
                                        'FilterWidth': 9500,
                                        'FilterLength': 10000,
                                        'filterStretchAt': 0,
                                        'filterStretchLen': 0,
                                        'DemodPhase': 0,
                                        'DemodCosAmp': 255,
                                        'DemodSinAmp': 255,
                                        'DemodFreq': -30*M,
                                        'ADCDelay': 0
                                    },
                    'Variables': ['ADC Time'],
                },
                { # GPIB RF Generator.
                    'Resource': 'RF Generator',
                    'Server': 'GPIB RF Generators',
                    'Address': 'GPIB Bus - GPIB0::10',
                    'Variables': {
                                    'RF Power': 'Power', 
                                    'RF Frequency': 'Frequency'
                                 }
                },
                { # Lab Brick Attenuator.
                    'Resource': 'Lab Brick Attenuator',
                    'Server': 'Lab Brick Attenuators',
                    'Address': 7032,
                    'Variables': 'RF Attenuation'
                { # SIM Voltage Source.
                    'Resource': 'Voltage Source',
                    'Server': 'SIM928',
                    'Address': 'GPIB0::10::SIM900::3',
                    'Variables': ['Bias Voltage']
                },
                { # External readings.
                    'Resource': 'Manual Record',
                    'Variables': ['Temperature']
                },
                { # Extra experiment parameters.
                    'Resource': 'Software Parameters',
                    'Variables': ['Runs'],
                }
              ]
            experiment_variables: experiment variable dictionary in the {'Variable Name': Value,...} format.
        Outputs:
            None.
        """
        self._set_information(experiment_information)
        self._set_resources(experiment_resources)
        self._set_variables(experiment_variables)
        
    def _set_information(self, experiment_information):
        """
        Sets experiment information, as well as base path for saving. 
        Base path will be: Base Path\User\Device\Date\Experiment Name\
        
        Inputs:
            experiment_information: dictionary (see set_experiment method for more information).
        Outputs:
            None.
        """
        # Check that all variables are in experiment_information as expected.   
        if 'Device Name' not in experiment_information:
            raise ExperimentDefinitionError('Device name is not specified.')
        if 'User' not in experiment_information:
            raise ExperimentDefinitionError('User is not specified.')
        if 'Base Path' not in experiment_information:
            raise ExperimentDefinitionError('Base path is not specified.')
        if 'Experiment Name' not in experiment_information:
            raise ExperimentDefinitionError('Experiment name is not specified.')
        if 'Comments' not in experiment_information:
            experiment_information['Comments'] = ''

        self.experiment_information = experiment_information
        
        # Make the base path if it does not exist.
        if not os.path.exists(experiment_information['Base Path']):
            try:
                os.makedirs(experiment_information['Base Path'])
            except:
                raise IOError('Could not create base path! Is AFS on?')
        
        # Get today's date in MM-DD-YY format, and make the save path.
        today = time.strftime("%m-%d-%y", time.localtime())
        self._save_path = os.path.join(experiment_information['Base Path'],
                                       experiment_information['User'],
                                       experiment_information['Device Name'],
                                       today,
                                       experiment_information['Experiment Name'])
        if not os.path.exists(self._save_path):
            try:
                os.makedirs(self._save_path)
            except:
                raise IOError('Could not create experiment save path! Is AFS on?')
    
    def _add_vars(self, resource):
        """
        Add experiment variables to self._vars from a resource. Specify some extra information that is may be required by other methods.
        
        Inputs:
            resource: a resource dictionary from a list of experiment resources.
        Outputs:
            None.
        """
        res = resource
        res.pop('Variables', None)
        res['Active'] = False
        res['Save'] = True
        if isinstance(resource['Variables'], str):
            self._vars[resource['Variables']] = res
        elif isinstance(resource['Variables'], list):
            for var in resource['Variables']:
                self._vars[var] = res
        elif iniinstance(resource['Variables'], dict):
            for var in resournce['Varibales'].keys():
                res['Setting'] = resource['Variables'][var]
                self._vars[vars] = res
        else:
            raise ExperimentDefinitionError("Variables in the resource dictionary " + str(resource) +
                " should be specified as a list of strings, a dictionary, or just as a simple string for a single variable.")
    
    def _set_resources(self, Resources):
        """
        Sets electronics information (what DACs, ADCs, and RF generators, Lab Bricks, etc. we are running), 
        initializes connections to the LabRAD servers.
        
        This methods also creates a map of the experiment variables defined in Resources to these resources.
        
        Inputs:
            Resources: a list of resource dictionaries (see set_experiment method for more information).
        Outputs:
            None.
        """
        self._vars = {}          # This dictionary maps the experiment variables to resources.
        self.FPGA = None            # LabRAD Server.
        DACs = {}                   # Dictionary of DAC boards with the list index as a key.
        ADCs = {}                   # Dictionary of ADC boards with the list index as a key.
        DACSettings = {}            # Dictionary of DAC board settings with the list index as a key. 
        ADCSettings = {}            # Dictionary of ADC board settings with the list index as a key.
        
        for resource in Resources:
            if 'Resource' not in resource:
                raise ExperimentDefinitionError("'Resource' key is not found in the resource dictionary: " + str(resource) + ".")
            if 'Variables' not in resource:
                raise ExperimentDefinitionError("'Variables' key is not found in the resource dictionary: " + str(resource) + ".")
            else:
                if not isinstance(resource['Variables'], str) and 
                   not isinstance(resource['Variables'], list) and
                   not isinstance(resource['Variables'], dict):
                    raise ExperimentDefinitionError("'Variables' key in the resource dictionary: " + str(resource) +
                        " should be defined as a list of experiment variables or as a simple string for a single variable.")
            
            self._add_vars(resource)
            
            # Lab Bricks attenuators, RF generators and voltage sources.
            if resource['Resource'].lower() in ['lab brick attenuator', 'rf generator', 'voltage source']:
                if 'Server' not in resource:
                    raise ExperimentDefinitionError("'Server' key is not found in the " + str(resource['Resource']) + " resource dictionary: " + str(resource) + ".")
                if 'Address' not in resource:
                    raise ExperimentDefinitionError("'Address' key is not found in the " + str(resource['Resource']) + " resource dictionary: " + str(resource) + ".")
                for var in resource['Variables']:
                    if resource['Resource'].lower() == 'lab brick attenuator':
                        self._vars[var]['Select Device'] = 'Select Attenuator'
                        if 'Setting' not in self._vars[var]:
                            self._vars[var]['Setting'] = 'Attenuation'
                    elif resource['Resource'].lower() == 'rf generator':
                        self._vars[var]['Select Device'] = 'Select Device'
                    elif resource['Resource'].lower() == 'voltage source':
                        self._vars[var]['Select Device'] = 'Select Device'
                        if 'Setting' not in self._vars[var]:
                            self._vars[var]['Setting'] = 'Voltage'

            # Link to GHz FPGAs server.         
            elif resource['Resource'] == 'GHz Boards':
                if 'Server' in not resource:
                    raise ExperimentDefinitionError("'Server' key is not found in the GHz Boards resource dictionary: " + str(resource) + ".")
                self.FPGA = self.cxn[resource['Server']]

            # Specify DAC boards.
            elif resource['Resource'] == 'DAC':
                if 'DAC Name' not in resource:
                    raise ExperimentDefinitionError("'DAC Name' key is not found in the DAC resource dictionary: " + str(resource) + ".")
                if 'List Index' not in resource:
                    raise ExperimentDefinitionError("'List Index' key is not found in the DAC resource dictionary: " + str(resource) + ".")
                if 'DAC Settings' not in resource:
                    raise ExperimentDefinitionError("'DAC Settings' key is not found in the DAC resource dictionary: " + str(resource) + ".")
                for channel in ['DAC A', 'DAC B']:
                    if channel not in resource['DAC Settings']:
                        raise ExperimentDefinitionError("'" + str(channel) + "' key is not found in the 'DAC Settings' dictionary: " +
                            str(resource['DAC Settings']) + " in '" + str(resource['DAC Name']) + "'.")    
                DACs[resource['List Index']] = resource['DAC Name']
                DACSettings[resource['List Index']] = resource['DAC Settings']
                self._add_vars(resource)
        
            # Specify ADC boards.
            elif resource['Resource'] == 'ADC':
                if 'ADC Name' not in resource:
                    raise ExperimentDefinitionError("'ADC Name' key is not found in the ADC resource dictionary: " + str(resource) + ".")
                if 'List Index' not in resource:
                    raise ExperimentDefinitionError("'List Index' key is not found in the ADC resource dictionary: " + str(resource) + ".")
                if 'ADC Settings' not in resource:
                    raise ExperimentDefinitionError("'ADC Settings' key is not found in the ADC resource dictionary: " + str(resource) + ".")
                ADCs[resource['List Index']] = resource['ADC Name']
                ADCSettings[resource['List Index']] = resource['ADC Settings']
                self._add_vars(resource)

            elif resource['Resource'].lower() in ['manual record', 'software parameters']:
                pass
            else:
                print("Warning: resource '" + str(resource['Resource']) + "' is not yet supported.")

        # Check that all DAC and ADC boards are unique.
        if len(DACs.values()) != len(set(DACs.values())):
            raise ExperimentDefinitionError("All DAC boards must have unique names in the resource dictionary. The following boards names are given: ", + str(DACs) + ".")
        if len(ADCs.values()) != len(set(ADCs.values())):
            raise ExperimentDefinitionError("All ADC boards must have unique names in the resource dictionary. The following boards names are given: ", + str(ADCs) + ".")
            
        # Create lists with the DAC and ADC boards as well as lists with ADC and DAC settings according to the specified indecies.
        self.DACs = [DACs[index] for index in sorted(DACs)]
        self.ADCs = [ADCs[index] for index in sorted(ADCs)]
        self.DACSettings = [DACSettings[index] for index in sorted(DACs)]
        self.ADCSettings = [ADCSettings[index] for index in sorted(ADCs)]
    
    def _set_variables(self, experiment_variables):
        """
        Sets experiment variables.
        
        Inputs:
            experiment_variables: experiment variable dictionary in the {'Variable Name': Value,...} format.
        Outputs:
            None.
        """
        if not hasattr(self, '_vars'):
            raise ExperimentDefinitionError('Experiment resources should be set prior setting experiment variables.')
        
        for var in experiment_variables:
            if var not in self._vars:
                print("Warning: experiment variable '" + str(var) + "' is not found in the experiment resources. The variable will be ignored.")
                self._vars[var]['Save'] = False
            self._vars[var]['Value'] = experiment_variables[var]
              
    def _check_var(self, var, value_check=True):
        """
        Asserts existance of an experiment variable
        
        Inputs:
            var: name of the experiment variable.
            value_check (optional): check whether the value is defined.
        Outputs:
            None.
        """        
        if not isinstance(var, str):
            raise ExperimentDefinitionError("'" + str(var) + "' is expected to be a string that defines an experiment variable.")
        if var not in self._vars:                                        # Check that the variable was set in the resource dictionary.
            raise ExperimentDefinitionError("'" + str(var) + "' variable is not found in the experiment resource dictionary.")
        if value_check and 'Value' not in self._vars[var]:                # Check that the variable value is defined.
            raise ExperimentDefinitionError("'" + str(var) + "' variable value is not defined.")
    
    def wrap_var(self, var, unit, value=None):
        """
        Asserts an experiment variable and returns its value.
        
        Inputs:
            var: name of the experiment variable.
            unit: units to convert to.
            value (optional): a new value to assign to the experiment variable.
        Outputs:
            value: value of the experiment variable var in specified units.
        """
        if not hasattr(self, '_vars'):
            raise ExperimentDefinitionError('Experiment resources and variables should be set prior accessing any variables.')
        if var not in self._vars:
            raise ExperimentDefinitionError("'" + str(var) + "' variable is not found in the experiment resource dictionary.")

        if 'Value' not in self._vars[var]:
            if value is None:
                value = 0 * unit

        self._vars[var]['Value'] = value
        self._vars[var]['Save'] = True

        return self._vars[var]['Value'][unit]
        
    def wrap_data_var(self, var, distr=None, pref = {}):
        """
        Asserts a data variable and assigns information that can be used for plotting.
        
        Inputs:
            var: name of the experiment variable.
            distr: expected statistical distribution (this information could be used for the errors estimation (default: None).
            pref: plotting preferences (default: {}).
        Outputs:
            None.
        """
        if not hasattr(self, '_data_vars'):
            raise Exception('Experiment resources and variables should be set prior setting data variable preferences.')
        
        # distribution guess. This is used for the error estimation.
        if distr is not None:
            self._data_vars[var]['distribution'] = distr
        
        # Define plotting preferences.
        self._data_vars[var]['Preferences'] = pref

    ###DATA SAVING METHODS###############################################################################
    #####################################################################################################
    def _TextSave(self, names, values, data, depend_dict={}):
        """
        Save data in human-readable text data file, new and improved version with better support for multidimensional data saves.
        Saves a header containing all experiment variables, then sweep variables, and then all variables in the data dictionary.
        """
        textFileFolder = os.path.join(self._save_path, 'TextData')
        
        if not os.path.exists(textFileFolder):
            try:
                os.makedirs(textFileFolder)
            except:
                raise Exception('Could not create experiment text data save path! Is AFS on?')
        
        #which contents are files?
        onlyfiles = [f for f in os.listdir(textFileFolder) if os.path.isfile(os.path.join(textFileFolder,f))]
        ExptName = self.experiment_information['Experiment Name'].replace(" ", "_")
        #which files start off with 'ExperimentName_'?
        files = [f.split('.')[0] for f in onlyfiles if f[:len(ExptName)+1]==ExptName+'_']
        
        #get file numbers and increment, or create first file if none in folder
        nums = [int(f[-3:]) for f in files if f[-3:].isdigit()]
        if nums==[]:
            num = '000'
            fname = ExptName+'_' + num + '.txt'
        else:
            num = ("%03d" % (max(nums)+1,))
            fname = ExptName+'_' + num +'.txt'
        
        #create the file path
        filePath = os.path.join(textFileFolder,fname)
        
        #build a header for the file
        h = []
        h.append(ExptName)
        h.append(time.asctime())
        h.append('====Experiment Parameters====')
    
        # Save only the variables that have been actually used. Do not save the sweep variables in the header.
        sweep_vars = [var for name_list in names for var in name_list]
        for var in self._vars:
            if var in self._vars and self._vars[var] is not None and var not in sweep_vars:
                h.append(var + ':   ' + ("%f" %self._vars[var]) + self._GetUnitsInBrackets(var))

        if 'Comments' in self.experiment_information:
            h.append('Comments:   ' + self.experiment_information['Comments'])
        
        h.append('====Sweep Variables====')
        with file(filePath, 'w') as outfile:
            for k in h:
                outfile.write(k + '\n')
            
            names_saved = [] # This is to avoid duplicative saving of the sweep variables when a parallel scan was run with the same variable name.
            for p_idx, value_list in enumerate(values):
                for idx, val in enumerate(value_list):
                    if names[p_idx][idx] not in names_saved:
                        outfile.write(names[p_idx][idx] + self._GetUnitsInBrackets(names[p_idx][idx]) + ':' + str(list(val.shape)) + '\n')
                        self._NDArrayTextSave(outfile, val)
                        names_saved.append(names[p_idx][idx])

            outfile.write('====Data Variables====\n');
            for key, val in data.items():
                extra = ''
                if key in depend_dict:
                    extra = '::' + str(depend_dict[key])
                if key in self._data_vars and self._data_vars[key] != '':
                    extra = extra + ':::[' + self._data_vars[key] + ']'
                outfile.write(key + self._GetUnitsInBrackets(key) + ':' + str(list(val.shape)) + extra + '\n')
                self._NDArrayTextSave(outfile, val)
                    
    def _NDArrayTextSave(self, outfile, array):
        if array.ndim == 1 or array.ndim == 2:
            np.savetxt(outfile, array, fmt = '%-7.6f', delimiter='\t')
        elif array.ndim > 2:
            for idx in range(array.shape[0]):
                self._NDArrayTextSave(outfile, array[idx])
                
    def _MatSave(self, names, values, data, depend_dict={}):
        """
        Save data as a .mat file using scipi.io. Data will be saved as a structure, with a substructure for
        the experiment and electronics, and arrays for the data.
        """
        MATLABFileFolder = os.path.join(self._save_path, 'MATLABData')
        
        if not os.path.exists(MATLABFileFolder):
            try:
                os.makedirs(MATLABFileFolder)
            except:
                raise Exception('Could not create experiment MATLAB data save path! Is AFS on?')
        
        #which contents are files?
        onlyfiles = [ f for f in os.listdir(MATLABFileFolder) if os.path.isfile(os.path.join(MATLABFileFolder,f))]
        ExptName = self.experiment_information['Experiment Name'].replace(" ","_")
        #which files start off with 'ExperimentName_'?
        files = [f.split('.')[0] for f in onlyfiles if f[:len(ExptName)+1]==ExptName+'_']
        
        #get file numbers and increment, or create first file if none in folder
        nums = [int(f[-3:]) for f in files if f[-3:].isdigit()]
        if nums==[]:
            num = '000'
            fname = ExptName + '_' + num + '.mat'
        else:
            num = ("%03d" % (max(nums)+1,))
            fname = ExptName + '_' + num + '.mat'
        
        filePath = os.path.join(MATLABFileFolder,fname)
        
        # Convert ExptVars names to a MATLAB-friendly format.
        # Save the variables that have been actually used. Do not save here the experiment variables that are sweep variables.
        matData = {}
        matExptVars = {}
        matUnits = {}
        sweep_vars = []
        for name_list in names:
            for name in name_list:
                sweep_vars.append(name)
        for var in self._vars:
            if var in self._vars and self._vars[var] is not None and var not in sweep_vars:
                matExptVars[var.replace(" ", "_")] = self._vars[var]
                matUnits[var.replace(" ", "_")] = self._GetUnits(var)
        
        # Create dictionary that will be saved to a .mat file.
        saveDict = {
                    'Time': time.asctime(),
                    'Name': ExptName + '_' + num,
                    'ExptVars': matExptVars,
                    'Comments': self.experiment_information['Comments']
                   }
        
        for key in data:
            matData[key.replace(" ", "_")] = data[key]
        for p_idx, value_list in enumerate(values):
            for idx, val in enumerate(value_list):
                matData[names[p_idx][idx].replace(" ", "_")] = val
        
        saveDict['Data'] = matData
        
        # Save the information about the data units and the expected distributions.
        matDatadistr = {}
        matDataDepend = {}
        for key in data:
            matUnits[key.replace(" ", "_")] = self._GetUnits(key)
            if key in self._data_vars:
                matDatadistr[key.replace(" ", "_")] = self._data_vars[key]
            if key in depend_dict:
                matDataDepend[key.replace(" ", "_")] = str(depend_dict[key]).replace(", ", ",").replace(" ", "_")
        if matUnits:
            saveDict['Units'] = matUnits
        if matDatadistr:
            saveDict['Datadistr'] = matDatadistr
        if matDataDepend:
            saveDict['DataDepend'] = matDataDepend
  
        sio.savemat(filePath, {saveDict['Name']: saveDict})                

    def _SaveData(self, names, values, data, depend_dict={}):
        """
        Save data as in a text (.txt) and a MATLAB (.mat) file formats.
        """ 
        for list_idx, value_list in enumerate(values):      # Remove unnecessary dimensions that contains only one value from the dependency specifications and independent variables.
            for idx, val in enumerate(value_list):
                if np.size(val) == 1:
                    for key in depend_dict:
                        depend_dict[key] = [name for name in depend_dict[key] if name != names[list_idx][idx]]
            values[list_idx] = [val for val in value_list if np.size(val) > 1]
            names[list_idx] = [names[list_idx][name_idx] for name_idx, val in enumerate(value_list) if np.size(val) > 1]
        depend_dict = {key: dep for key, dep in depend_dict.items() if len(dep) > 0}
        for key in data.keys():                             # Remove unnecessary dimensions that contain only one value.
            data[key] = np.squeeze(data[key])
            if np.size(data[key]) == 1:                     # Convert single numbers (zero-dimensional ndarrays) to one-dimensional ndarrays.
                data[key] = np.array([data[key]])
        
        self._TextSave(names, values, data, depend_dict)
        self._MatSave(names, values, data, depend_dict)
        print('The data has been saved.')
    
    ###UTILITIES#########################################################################################
    #####################################################################################################
    def _GetUnits(self, name):
        if name in self.Units:
            return self.Units[name]
        else:
            return ''
    
    def _GetUnitsInBrackets(self, name):
        if name in self.Units and self.Units[name] != '':
            return ' [' + self.Units[name] + ']'
        else:
            return ''
            
    def _CombineStrsOrStrLists(*args):
        vars = []
        for arg in args:
            if arg is not None:
                if isinstance(arg, str):
                    vars = vars + [arg]
                elif isinstance(arg, list):
                    if any([not isinstance(var, str) for var in arg]):
                        print('Warning: internal method _CombineStrsOrStrLists can only accept strings or lists of strings as its arguments.')
                    else:
                        vars = vars + arg
        result = []
        for var in vars:
            if var not in result:
                result.append(var)
        
        return result
    
###DATA POSTPROCESSING METHODS#######################################################################
#####################################################################################################
    def _MeanTimeFromArray(self, t, threshold):
        t = np.array(t)
        t = t[t < threshold]
        if np.size(t) > 0:
            t_mean = np.mean(t)
            t_std = np.std(t)
        else:
            t_mean = -1
            t_std = 0

        return t_mean, t_std

    def _MeanTimeDiffFromArray(self, t, threshold):
        t = np.array(t)
        dt = t[0][:] - t[1][:]
        dt = dt[np.logical_and(t[0][:] < threshold, t[1][:] < threshold)]
        if np.size(dt) > 0:
            dt_mean = np.mean(dt)
            dt_std = np.std(dt)
        else:
            dt_mean = 0
            dt_std = 0

        return dt_mean, dt_std

    def _SwitchProbFromArray(self, t, threshold):
        t = np.array(t)

        return float(np.size(t[t < threshold])) / float(np.size(t))
        
    def _PreAmpTimeCountsTo10Array(self, t, threshold):
        """
        Takes a switch probability result array from the DAC timer, and converts to a numpy array of 0 or 1 based on the
        threshold.
        """
        def _Threshold(x):
            if x < threshold:
                return 1
            else:
                return 0
        
        ThresholdVectorized = np.vectorize(_Threshold)

        return ThresholdVectorized(t)
        
    def _SoftwareDemodulate(self, t, Is, Qs, ADCName=None):
        '''
        Demodulate I and Q data in software. Uses ADC frequency for demod. 
        
        Input:
            t: time vector during which to demodulate data (ns)
            Is: I data
            Qs: Q data
        Output:
            Id, Qd: demodulated I and Q
        '''
        demod = 2 * np.pi * t * self.ADCSettings[self.ADCs.index(self._GetADCName(ADCName))]['DemodFreq'] / G
        
        Sv = np.sin(demod)
        Cv = np.cos(demod)

        Id = np.mean(Is * Cv - Qs * Sv)
        Qd = np.mean(Is * Sv + Qs * Cv)
        
        return Id, Qd

###DAC AND ADC BOARD INTERFACE#######################################################################
#####################################################################################################
    def LoadAndRun(self, SRAM, memory, reps=1000, experiment_type='PreAmp', ADCIndex=0):
        """
        Loads FPGA boards with the required memory and settings, and executes the run sequence a set number of times. Should be called at the end of each RunOnce.
        SRAM and Memory should be lists which correspond to the the DAC SRAM and Memory in the order in which they are defined in the Electronics
        information dictionary. The first listed DAC is always assumed to be the master. 
        
        Inputs:
            --SRAM: List of DAC SRAM waves. Use DAC.waves2sram to get the right format
            --Memory: List of memory commands. Use any of the memory tools in DAC_control to build a memory sequence
            --UseADC: return data from ADCs (True) or DACs (False)
            --reps: number of repetitions in the sequence
        Outputs:
            --RunData: returns the result of the fpga.run_sequence command
        """
        if (len(SRAM)!=len(self.DACs))|(len(memory)!=len(self.DACs)):
            raise Exception('Not enough SRAM or DAC commands to populate the boards!')
        
        DAC.LoadDACs(self.FPGA, memory, SRAM, self.DACs)
        
        if experiment_type == 'ADC':
            self.FPGA.daisy_chain(list(itertools.chain(*[self.DACs,self.ADCs]))) #determines which set of boards to run, not the order
            if self.ADCSettings[ADCIndex]['RunMode']=='average':
                self.FPGA.timing_order([self.ADCs[0]])
            elif self.ADCSettings[ADCIndex]['RunMode']=='demodulate':
                timingOrderList = ['%s::%d' %(self.ADCs[0],0)] #record channel 0 fpga.timing_order(timingOrderList)
                self.FPGA.timing_order(timingOrderList)
            else:
                raise Exception('ADC RunMode should be either ''average'' or ''demodulate'' (case sensitive).')
            DAC.LoadADCs(self.FPGA, self.ADCs, self.ADCSettings)
        elif experiment_type == 'PreAmp':
            self.FPGA.daisy_chain(list(itertools.chain(*[self.DACs]))) #determines which set of boards to run, not the order
            self.FPGA.timing_order([self.DACs[0]])  
        elif experiment_type == 'MultiPreAmp':
            self.FPGA.daisy_chain(list(itertools.chain(*[self.DACs]))) #determines which set of boards to run, not the order
            self.FPGA.timing_order(self.DACs) 
        else:
            raise Exception("Experiment type '" + experiment_type + "' is not supported.")

        return self.FPGA.run_sequence(reps, True)

###EXPERIMENT CONTROL METHODS########################################################################
#####################################################################################################
    def Variable(self, name, value=None):
        """
        Get or set a single variable in the experiment variables dictionary. Useful if you want to run a single point experiment or over a few
        different values. 
        
        Inputs:
            name: name of the variable key in the experiment variables dictionary
            value: optional parameter. if not included, function returns value of existing parameter or None if key is not in dictionary.
                Otherwise, sets variable to Value if it exists in dictionary. Raises an exception if no variable with Name exists!
        Outputs:
            value of desired variable, or None if it does not exist in dictionary
        """
        if value is None:
            if name in self._vars:
                return self._vars[name]['Value']
            else:
                return None
        else:
            if Name not in self._vars:
                raise ExperimentDefinitionError("'" + str(Name) + "' key is not found in the experiment variables dictionary: " + 
                                                 str(self._vars) + ".")
            else:
                self._vars[Name] = Value
                print("Experiment variable '" + Name + ("' is set to %f" %Value) + self._GetUnitsInBrackets(Name) + ".")
                
    def ChangeADCSetting(self, ADCName, setting, value):
        """
        Change one of the ADC settings.
        
        Inputs:
            ADCName: name string of the ADC. If ADCName is None and there is only one board in the resource dictionary, it will be automatically recognized.
            setting: name of setting you want to change.
            value: value to change the setting to.
        Outputs:
            None.
        """
        ADCName = self._GetADCName(ADCName)
        
        if setting not in self.ADCSettings[self.ADCs.index(ADCName)]:
            raise ExperimentDefinitionError(str(setting) + " is not a valid ADC setting name.")
        else:
            self.ADCSettings[self.ADCs.index(ADCName)][setting] = value
            
    def _GetADCName(self, ADCName=None):
        """
        Check whether the ADC Board with a specific name exist. If the input ADC board name is not specified and there is only one ADC board
        in the resource dictionary, then the name of this board is returned.
        
        Inputs: 
            ADCName: the name of an ADC board.
        Outputs: 
            ADCName: the name of an existing ADC board (i.e. either given as input ADCName or found in the resource dictionary).
        """
        if ADCName is None:
            if len(self.ADCs) == 1:
                ADCName = self.ADCs[0]
            else:
                raise("The ADC board name should be explicitly specified since there are more than one ADC board in the experiment resource dictionary.")
        elif ADCName not in self.ADCs:
            raise Exception("ADC board '" + str(ADCName) + "' does not exist.")

        return ADCName    
    
    ###EXPERIMENT RUN FUNCTIONS##########################################################################
    #####################################################################################################
    def set_var_request(self, var, enforce=True, value=None)
        if var not in self._vars:
            if enforce:
                raise ExperimentDefinitionError("Variable '" + str(var) + "' is not defined in the resource list.")
            else:
                return
        
        if value is not None:
            self._vars['Value'] = value
        
        p = self._cxn[self._vars['Server']].packet()
        p[self._vars['Select Device']](self._vars['Address'])
        p[self._vars['Setting']](self._vars['Value'])
        self._vars['Result'] = p.send(wait=False)
        self._vars['Active'] = True
        self._vars['Save'] = True
        
    def acknowledge_request(self, var)
        if var not in self._vars:
            raise ExperimentDefinitionError("Variable '" + str(var) + "' is not defined.")
        
        if self._vars['Active']:
            self._vars['Result'] = self._vars['Result'].wait()
            self._vars['Active'] = False
            return self._vars['Result'][self._vars['Setting']]

    def RunOnce(self):
        """
        Basic run method. In Experiment this does nothing, and should be what is modified in each specific inherited experiment class.
        RunOnce() will be called by each of the sweep running methods so that these don't have to be redefined in each method.
        In the inherited classes this should run one experiment (i.e. one set of RF/memory/SRAM commands) with the variables as 
        currently defined in the experiment variable dictionary.
        
        This function should return a "data" and an "extra data" dictionaries.
        
        Inputs: 
            None
        """
        pass
        
    def RunMultipleTimesAndAverage(self, Runs):
        """
        This method is similar to RunOnce with the exception that the experiment defined by RunOnce() method will be called
        Run number of times and the results of all runs will be averaged.
        
        This function should return a "data" and an "extra data" dictionaries.
        
        Inputs: 
            Runs: number of independent runs of the experiment.
        """
        self._WrapExptVar('Runs', '', Runs)
        standard_output_flag = self._StandardOutputFlag
        
        for idx in range(Runs):
            run_data, extra_data = self.RunOnce()
            if idx == 0:
                if self._StandardOutputFlag:
                    sys.stdout.write('Progress at current data point: 0%')
                data = {}
                for key in run_data:
                    data[key] = np.zeros((Runs,) + np.shape(run_data[key]))              
            for key in data:
                data[key][idx] = run_data[key]
            self._ListenKeyboard()
            if self._RunStatus == 'abort':
                if standard_output_flag:
                    sys.stdout.write(str(round(100 * (idx + 1) / float(Runs), 1)) + '%\n')
                break
            if standard_output_flag:
                sys.stdout.write('.')
                if idx == Runs - 1:
                    sys.stdout.write('100%\n')  

        return self._AverageData(data, extra_data)

    def _AverageData(self, data, extra_data):
        """
        This method should be used for proper averaging of the data returned by RunOnce method.
        
        The method should return a "data" and an "extra data" dictionaries.
        
        Inputs: 
            Runs: number of independent runs of the experiment.
        """
        avg_data = {}
        for key in data:
            self.wrap_data_var(key, self._GetUnits(key), 'normal')
            self.wrap_data_var(key + ' Std Dev', self._GetUnits(key), 'std')
            avg_data[key] = np.mean(data[key], axis=0)            
            avg_data[key + ' Std Dev'] = np.std(data[key], axis=0)
        
        return avg_data, extra_data
        
    def SingleShotIQs(self, ADCName=None, Save=False, PlotData=None):
        """
        Run a single experiment, saving individual I and Q points.
        
        Inputs:
            ADCName: the ADC board name. If the board is not specified and there is only one board in experiment resource dictionary than it will be used by default.
            Plot: plot the data (True by default).
            Save: save the data if Save is True.
        Outputs:
            None.
        """
        ADCName = self._GetADCName(ADCName)
        previousADCmode = self.ADCSettings[self.ADCs.index(ADCName)]['RunMode']
        self.ADCSettings[self.ADCs.index(ADCName)]['RunMode'] = 'demodulate'
            
        run_data, extra_data = self.RunOnce()
        
        self.ADCSettings[self.ADCs.index(ADCName)]['RunMode'] = previousADCmode
        
        if PlotData is not None:
            plt.ion()
            plt.figure(13)
            plt.plot(run_data['Single Shot Is'], run_data['Single Shot Qs'], 'b.')
            plt.xlabel('I [ADC units]')
            plt.ylabel('Q [ADC units]')
            plt.title('Single Shot Is and Qs')
            plt.draw()

        if Save:        # Save the data.
            self._SaveData(extra_data['Indep Names'], extra_data['Indep Vals'], run_data, extra_data['Dependencies'])

    def SingleShotOsc(self, ADCName=None, Save=False, PlotData=None):
        """
        Run a single shot experiment in average mode, and save the time-demodulated data to file.
        
        Inputs: 
            ADCName: the ADC board name. If the board is not specified and there is only one board in experiment resource dictionary than it will be used by default.
            Save: save the data if Save is True.
            PlotData: data variables to plot.
        Outputs:
            None.
        """
        self.AvgOsc(ADCName, Save, PlotData, Runs=1)

    def AvgOsc(self, ADCName=None, Save=False, PlotData=None, Runs=100):
        '''
        Run a single experiment in average mode Reps number of times (or self.ExptVar['Reps'] if 'Reps' is None) and average the results together.
        
        Inputs:
            Plot: plot the data after we are done?
            Save: save the data to disk
            PlotData: data variables to plot.
            Runs: number of runs (100 by default).
        Outputs:
            None.
        '''
        print('\nCollecting the ADC data...\n')
              
        self._RunStatus = ''
        self._RunMessage = ''
        
        ADCName = self._GetADCName(ADCName)
        previousADCmode = self.ADCSettings[self.ADCs.index(ADCName)]['RunMode']
        self.ADCSettings[self.ADCs.index(ADCName)]['RunMode'] = 'average'
        
        run_data, extra_data = self.RunOnce()
        
        if PlotData is not None:        # Make a list of data variables that should be plotted.
            for var in self._CombineStrsOrStrLists(PlotData):
                if var not in run_data:
                    print("Warning: key '" + var + "' does not exist in the data dictionary: " + str(run_data) + ".")
            PlotData = [var for var in self._CombineStrsOrStrLists(PlotData) if var in run_data]
        if PlotData:
            self._Initialize1DPlot(extra_data['Indep Vals'][0][0], run_data, extra_data['Indep Names'][0][0], PlotData)

        if Runs > 1:                    # Run multiple measurement shots.
            print('\t[ESC]:\tAbort the run.' + 
                  '\n\t[S]:\tAbort the run but [s]ave the data.\n')
            sys.stdout.write('Progress: 0%')
            self._WrapExptVar('Runs', '', Runs)
            stepsize = max(int(round(Runs / 25)), 1)
            plot_data = run_data
            for r in range(Runs - 1):
                self._ListenKeyboard(RecogKeys=[27, 83, 115], ClearBuffer=False)  # Check if the specified keys are pressed.
                if self._RunStatus in ['abort', 'abort-and-save']:
                    self._vars['Runs'] = r + 1
                    sys.stdout.write(str(round(100 * self._vars['Runs'] / float(Runs), 1)) + '%\n')
                    print(self._RunMessage)
                    break  
                single_run_data, extra_data = self.RunOnce()
                for key in run_data:    # Accumulate the data values. These values should be divided by the actual number of Reps to get the average values.
                    run_data[key] = run_data[key] + single_run_data[key]
                if np.mod(r, stepsize) == 0:
                    sys.stdout.write('.')
                    if PlotData:
                        for key in PlotData:
                            plot_data[key] = run_data[key] / float(r + 1)
                        self._Update1DPlot(extra_data['Indep Vals'][0][0], plot_data, extra_data['Indep Names'][0][0], PlotData)
                if r == Runs - 2:
                    sys.stdout.write('100%\n')
            for key in run_data:
                run_data[key] = run_data[key] / float(Runs)
        
        if PlotData:        # Save the data.
            self._Update1DPlot(extra_data['Indep Vals'][0][0], run_data, extra_data['Indep Names'][0][0], PlotData)
        
        self.ADCSettings[self.ADCs.index(ADCName)]['RunMode'] = previousADCmode
        
        if (Save and self._RunStatus != 'abort') or self._RunStatus == 'abort-and-save':        # Save data.
            self._SaveData(extra_data['Indep Names'], extra_data['Indep Vals'], run_data, extra_data['Dependencies'])

    def _Sweep(self, names, values, PrintExptVars=None, PrintDataVars=None, PlotDataVars=None, MaxDataDim=2, Runs=1):
        """
        Run an N-dimensional sweep over a given set of variables, defined by the keys in the experiment variable dictionary.
        In the most general case names and values should be list of lists of strings and 1D numpy arrays of the same structure. 
        The experiment and data variables that should printed and/or plotted should be specified when necessary.
        
        Inputs:
            names: names of the variable over which to sweep.
            values: values over which the sweep the variables.
            Save: the data will be saved if this flag is True.
            PrintData (optional): data variables to print to the standard output as a list of strings (or a string).
            PlotData (optional): data variables to plot as a list of strings (or a string).
            Dependencies (optional): dependency specifications.
            MaxDataDim (optional): limit on the maximum dimension of the data array. This prevents saving unnecessary large data sets when it is not required.
            Runs (optional): number of experiment runs at each point, the output data will be averaged.
        Outputs:
            None.
        """
        if len(names[0]) == 1:                                                  # Run a 1D sweep.
            for idx in range(values[0][0].size):
                for p_idx in range(len(names)):
                    self._vars[names[p_idx][0]] = values[p_idx][0][idx]
                    
                if Runs == 1:
                    run_data, extra_data = self.RunOnce()                       # Actual run of the experiment.
                else:
                    run_data, extra_data = self.RunMultipleTimesAndAverage(Runs)# Run the same experiment multiple times.
                
                self._SweepPointsAcquired = self._SweepPointsAcquired + 1 
            
                if idx == 0:
                    data = {}
                    for key in run_data:
                        data_entry_shape = np.shape(values[0][0]) + np.shape(run_data[key])
                        if len(data_entry_shape) <= MaxDataDim:
                            data[key] = np.empty(data_entry_shape)

                    if PrintExptVars is not None:                               # Make a list of the sweep variables that should be printed to the standard output.
                        for var in self._CombineStrsOrStrLists(PrintExptVars):
                            if var not in self._vars:
                                print("Warning: key '" + str(var) + "' has not been found in the following experiment variables dictionary: " + 
                                    str([var for var in self._vars]) + ". The value of this variable will not be printed.")
                        PrintExptVars = [var for var in self._CombineStrsOrStrLists(PrintExptVars) if var in self._vars]

                    if PrintDataVars is None:                                   # Make a list of the data variables that should be printed to the standard output.
                        PrintDataVars = [var for var in run_data if np.size(run_data[var]) == 1]
                    else:
                        for var in self._CombineStrsOrStrLists(PrintDataVars):
                            if var not in run_data and var not in self._vars:
                                print("Warning: key '" + str(var) + "' has not been found in the following data dictionary: " + str(run_data) + ". This data will not be printed.")
                        PrintDataVars = [var for var in self._CombineStrsOrStrLists(PrintDataVars) if var in run_data and np.size(run_data[var]) == 1]
                        
                    if PlotDataVars is not None:                                # Make a list of the data variables that should be plotted.
                        for var in self._CombineStrsOrStrLists(PlotDataVars):
                            if var not in run_data:
                                print("Warning: key '" + var + "' has not been found in the following data dictionary: " + str(run_data) + ". This data will not be plotted.")
                        PlotDataVars = [var for var in self._CombineStrsOrStrLists(PlotDataVars) if var in run_data and np.size(run_data[var]) == 1]
                        if PlotDataVars and values[0][0].size > 1:     # Determine the X axis label.
                            SameXAxis = True
                            SimilarXAxes = True
                            for p_idx in range(len(names)):
                                if names[p_idx][0] != names[0][0]:
                                    SameXAxis = False
                                if (values[p_idx][0] != values[0][0]).any() or self._GetUnits(names[p_idx][0]) != self._GetUnits(names[0][0]):
                                    SimilarXAxes = False
                                if SameXAxis == False and SimilarXAxes == False:
                                    break
                            if SameXAxis:
                                self._Initialize1DPlot(values[0][0], data, names[0][0], PlotDataVars)
                            elif SimilarXAxes:
                                self._Initialize1DPlot(values[0][0], data, [nm[0] for nm in names], PlotDataVars)
                            else:
                                self._Initialize1DPlot(np.array(range(values[0][0].size)), data, 'Run Iteration (along Fast Axis)', PlotDataVars)
                        else:
                            PlotDataVars = None  

                for key in data:                                                # Add the newly acquired data to the data set.
                    data[key][idx] = run_data[key]
                
                if self._StandardOutputFlag and self._RunStatus != 'abort':     # Print experiment and data variables to the standard output.
                    for var in PrintExptVars:
                        print(var + (' = %f' %self._vars[var]) + self._GetUnitsInBrackets(var))
                    for var in PrintDataVars:
                        print(var + (' = %f' %run_data[var]) + self._GetUnitsInBrackets(var))
                
                if PlotDataVars is not None and idx > 0:                        # Update the plot when it makes sense to do so.
                    if SameXAxis:
                        self._Update1DPlot(values[0][0][:idx+1], data, names[0][0], PlotDataVars)
                    elif SimilarXAxes:
                        self._Update1DPlot(values[0][0][:idx+1], data, [nm[0] for nm in names], PlotDataVars)
                    else:
                        self._Update1DPlot(np.array(range(idx+1)), data, 'Run Iteration (along Fast Axis)', PlotDataVars)

                if self._RunStatus == '':
                    self._ListenKeyboard()                                      # Check whether any key is pressed.
                if self._RunMessage != '':
                    print(self._RunMessage)
                    self._RunMessage = ''
                if self._RunStatus == 'abort':
                    break
                elif self._RunStatus == 'abort-and-save':                       # The scan has been aborted.
                    for p_idx in range(len(values)):
                        values[p_idx] = [np.delete(values[p_idx][0], np.s_[idx+1:], None)]      # Delete unused sweep variable values.
                    for key in data:
                        data[key] = np.delete(data[key], np.s_[idx+1:], 0)                      # Delete unfilled data points since the data has been previously initialize with np.empty.
                    break

            return data, values, extra_data
        else:                                                                   # Recurrent implementation multidimensional sweeps.
            run_names = []
            run_vals = []
            for p_idx in range(len(names)):
                run_names.append(names[p_idx][1:])
                run_vals.append(values[p_idx][1:])
                
            for idx0 in range(values[0][0].size):
                for p_idx in range(len(names)):                                 # Assign new values for the sweep variables.
                    self._vars[names[p_idx][0]] = values[p_idx][0][idx0]
                run_data, vals, extra_data = self._Sweep(run_names, run_vals, PrintExptVars, PrintDataVars, PlotDataVars, MaxDataDim, Runs)
                
                if idx0 == 0:                                                   # Initialize data dictionary.
                    data = {}
                    for key in run_data:
                        data_entry_shape = np.shape(values[0][0]) + np.shape(run_data[key])
                        if len(data_entry_shape) <= MaxDataDim:
                            data[key] = np.empty(data_entry_shape)
                
                if self._RunStatus == 'abort-and-save':
                    if idx0 == 0:                                               # The experiment was aborted during the acquisition of the first slice.
                        for p_idx in range(len(values)):
                            values[p_idx] = [np.array([values[p_idx][0][0]])] + vals[p_idx]
                        for key in data:
                            data[key] = run_data[key]
                    elif np.shape(vals[0][0]) == np.shape(values[0][1]):        # A full data slice has been acquired.
                        for p_idx in range(len(values)):
                            values[p_idx] = [np.delete(values[p_idx][0], np.s_[idx0+1:], None)] + values[p_idx][1:]
                        for key in data:
                            data[key][idx0] = run_data[key]
                            data[key] = np.delete(data[key], np.s_[idx0+1:], 0)
                    else:                                                        # The slice hasn't been fully acquired.
                        for p_idx in range(len(values)):
                            values[p_idx] = [np.delete(values[p_idx][0], np.s_[idx0:], None)] + values[p_idx][1:]
                        for key in data:
                            data[key] = np.delete(data[key], np.s_[idx0:], 0)
                    break
                elif self._RunStatus == 'abort':
                    break
                
                for key in data:                                                 # Add the newly acquired data to the data set.
                    data[key][idx0] = run_data[key]

            return data, values, extra_data
            
    def Sweep(self, names, values, Save=False, PrintData=None, PlotData=None, Dependencies=None, MaxDataDim=2, Runs=1):
        """
        Run an N-dimensional sweep over a given set of variables, defined by the keys in the experiment variable dictionary.
        In the most general case names and values should be list of lists of strings and 1D numpy arrays. The data
        will be saved with some non-public methods if Save flag is True. The experiment and data variables that should printed and/or 
        plotted could be specified when necessary.
        
        Inputs:
            names: names of the variable over which to sweep.
            values: values over which the sweep the variables.
            Save: the data will be saved if this flag is True.
            PrintData (optional): data variables to print to the standard output as a list of strings (or a string).
            PlotData (optional): data variables to plot as a list of strings (or a string).
            Dependencies (optional): dependency specifications.
            MaxDataDim (optional): limit on the maximum dimension of the data array. This prevents saving unnecessary large data sets when it is not required.
            Runs (optional): number of the experiment runs at each point, the output data will be averaged (using _AverageData method).
        Outputs:
            None.
        
        Examples:
            run.Sweep([['RF Frequency'], ['RF Frequency']], [[np.array([1e9, 2e9, 3e9])], [np.array([1e9, 2e9, 3e9])]], 
                      Save=True, PrintData=['Pa', 'Pb'], PlotData=['Pa', 'Pb'], Dependencies=[['Pa'], ['Pb']])
                 
            run.Sweep([['x'], ['y']], [[xval], [yval]], Save=True,  PrintData=['Result 1', 'Result 2'], PlotData=['Result 1', 'Result 2'])
        """
        if not hasattr(self, '_vars') or not hasattr(self, 'ExptVars'):
            raise Exception('Experiment resources and variables should be set prior attempting any scans.')

        ExcptMsg = ('The first argument in Sweep method should be either a string (for a 1D simple scan), '
                    'a list of strings (for a multidimensional scan), or a list of lists of strings (for a parallel any-dimensional scan).')
        if isinstance(names, str):      # If there is only one sweep variable defined as a string, convert it to a list of lists for internal code consistency.
            self._check_var(names)   # Check that the variable is properly defined.
            names = [[names]]
        elif isinstance(names, list):   # If there are no independent parallel scans, convert the list to a list of lists for internal code consistency.
            if len(names) > 0 and isinstance(names[0], str):        # Check that there are more than zero elements and confirm that they are strings.
                for name in names:                                  # Check that the variables are properly defined.
                    self._check_var(name)
                if len(names) > len(set(names)):                    # Check that the variables are unique.
                    raise SweepError('Sweep method was called with repeated variable names. The data might be hard to interpret.')
                names = [names]
            elif len(names) > 0 and isinstance(names[0], list) and len(names[0]) > 0:     # Do the following checks if a list of lists of strings is actually specified.
                for name_list in names:
                    if not isinstance(name_list, list):             # Check that all nested elements are lists.
                        raise SweepError(ExcptMsg)
                    if len(name_list) != len(names[0]):             # Check that the nested lists have the same length.
                        raise SweepError('The length of name lists should be the same for any parrallel scans.') 
                    for name in name_list:                          # Check that the variables are properly defined.
                        self._check_var(name)
                    if len(name_list) > len(set(name_list)):        # Check that the variables are unique.
                        raise SweepError('Sweep method was called with repeated variable names.')
                for list_idx1, name_list1 in enumerate(names):      # Check that there are no repeated variable names along different scan axes.
                    for name_idx1, name1 in enumerate(name_list1):
                        for name_list2 in names[list_idx1+1:]:
                            for name_idx2, name2 in enumerate(name_list2):
                                if name_idx1 != name_idx2 and name1 == name2: # Repeated variable names along the same axis are allowed!
                                    raise SweepError('Sweep method was called with repeated variable names along differenent scan axes.')
            else:
                raise SweepError(ExcptMsg)
        else:
            raise SweepError(ExcptMsg)
        
        ExcptMsg = ('The second argument in Sweep method should be either a 1D numpy array (for a 1D simple scan), '
                   'a list of 1D numpy arrays (for a multidimensional scan) or a list of lists of 1D numpy arrays (for a parallel any-dinesional scan). '
                   'For parallel scans, the length of the 1D numpy arrays should be equal along the same scan axis. Each numpy array should contain at least one number.')
        if isinstance(values, np.ndarray):                          # If there is only one sweep variable defined as a 1D numpy array, convert it to a list of lists for internal code consistency.
            if np.ndim(values) != 1:                                # Check the number of dimensions.
                raise SweepError(ExcptMsg)
            values = [[values]]
        elif isinstance(values, list):                              # If there are no independent parallel scans, convert the list of 1D numpy arrays to a list of lists for internal code consistency.
            if len(values) > 0 and isinstance(values[0], np.ndarray):
                for value in values:            
                    if not isinstance(values[0], np.ndarray) or np.ndim(value)!= 1:         # Check the type and number of the dimensions.
                        raise SweepError(ExcptMsg)
                values = [values]
            elif len(values) > 0 and isinstance(values[0], list) and len(values[0]) > 0:    # Do the following checks if a list of lists of 1D numpy arrays is actually specified.
                for value_list in values:
                    if not isinstance(value_list, list):            # Check that all nested elements are lists.
                        raise SweepError(ExcptMsg)
                    if len(value_list) != len(values[0]):           # Check that the nested lists have the same length.
                        raise SweepError('The length of 1D numpy array lists should be the same for each parrallel scan.') 
                    for value in value_list:                        # Check that all sub-nested elements are non-empty 1D numpy arrays.
                        if not isinstance(value, np.ndarray) or np.ndim(value) != 1 or np.size(value) == 0:
                            raise SweepError(ExcptMsg)
                for list_idx, value_list in enumerate(values):      # Check that numpy arrays have the same length along the same scan axis.
                    for value_idx, value in enumerate(value_list):
                        if len(values[0]) <= value_idx or (list_idx > 0 and values[0][value_idx].size != value.size):
                            raise SweepError(ExcptMsg)
            else:
                raise SweepError(ExcptMsg)
        else:
            raise SweepError(ExcptMsg)
        
        if len(names) != len(values):                               # Check that the names and values can be directly mapped to each other.
            raise SweepError('Sweep method was called with variable names that specified in a way could not be unambigiously matched to the values.')
        for list_idx, name_list in enumerate(names):
            if len(name_list) != len(values[list_idx]):
                raise SweepError('Sweep method was called with variable names that specified in a way could not be unambigiously matched to the values.')
        
        for list_idx1, name_list1 in enumerate(names):              # Prevent any attempts to set any sweep variable twice to different values.
            for name_idx1, name1 in enumerate(name_list1):          # Otherwise, it would be really hard to interpret the data.
                for list_idx2, name_list2 in enumerate(names):
                    if list_idx2 > list_idx1 and name1 == name_list2[name_idx1] and (values[list_idx1][name_idx1] != values[list_idx2][name_idx1]).any():
                        raise SweepError('Sweep method was called with repeated variable names along some scan axis ' +
                                            'but the 1D numpy value arrays corresponding to these variables are not the same.')
        
        ExcptMsg = ('Optional parameter Dependencies in Sweep method should be either a string (for a 1D simple scan), '
                    'a list of strings (for a multidimensional scan), or a list of lists of strings (for parallel any-dimensional scans).')
        if Dependencies is not None:                                # If any dependencies are specified, check the following.
            if isinstance(Dependencies, str):                       # If there is only one dependency is specified, convert it to a list of lists for internal code consistency.
                Dependencies = [[Dependencies]]
            elif isinstance(Dependencies, list):
                if len(Dependencies) > 0 and isinstance(Dependencies[0], str):      # If only a simple list is specified, convert this list of strings to a list of lists for internal code consistency.
                    for dep in Dependencies:
                        if not isinstance(dep, str):                                # Check that all nested elements are strings.
                            raise SweepError(ExcptMsg)
                    Dependencies = [list(set(Dependencies))]
                elif len(Dependencies) > 0 and isinstance(Dependencies[0], list):
                    for list_idx, dep_list in enumerate(Dependencies):
                        if not isinstance(dep_list, list):                          # Check that all nested elements are lists.
                            raise SweepError(ExcptMsg)
                        for dep in dep_list:
                            if not isinstance(dep, str):                            # Check that all sub-nested elements are strings.
                                raise SweepError(ExcptMsg)
                        Dependencies[list_idx] = list(set(dep_list))
                    for list_idx, dep_list1 in enumerate(Dependencies):             # Check that the same data variable does not have any duplicated dependency specifications.
                        for dep1 in dep_list1:
                            for dep_list2 in Dependencies[list_idx+1:]:
                                for dep2 in dep_list2:
                                    if dep1 == dep2:
                                        raise SweepError('Sweep method was called with conflicted dependency specifications.')
                else:
                    raise SweepError(ExcptMsg)
            else:
                raise SweepError(ExcptMsg)

        self._RunStatus = ''                                        # E.g. 'abort' or 'abort-and-save'.
        self._RunMessage = '';
        self._SweepDimension = len(names[0])                        # Dimension of the sweep.
        self._SweepStartTime = time.time()                          # Start time for the finish time estimation.
        self._SweepNumberOfPoints = 1                               # Total number of measurement points.
        for val in values[0]:
            self._SweepNumberOfPoints = len(val) * self._SweepNumberOfPoints
        self._SweepPointsAcquired = 0                               # Number of the acquired data points.

        print('\nStarting a ' + str(self._SweepDimension) + 'D data sweep...\n' + 
              '\n\t[ESC]:\tAbort the run.' + 
              '\n\t[S]:\tAbort the run but [s]ave the data.' +
              '\n\t[T]:\tEstimate the finish [t]ime for the current scan.' +
              '\n\t[O]:\tTurn [o]n/[o]ff data printing to the standard [o]utput.' + 
              '\n\t[X]:\tSecret option.\n')
        
        PrintExptVars = []
        for name_list in names:
            PrintExptVars = PrintExptVars + name_list
        
        data, values, extra_data = self._Sweep(names, values, PrintExptVars, PrintData, PlotData, MaxDataDim, Runs)

        if (Save and self._RunStatus != 'abort') or self._RunStatus == 'abort-and-save':
            if values[0][0].size > 0:                               # If there is at least one point to save then...
                if Dependencies is None and len(names) == 1:        # Create a dictionary that specifies the dependency of the data variables on the sweep variables.
                    Dependencies = [data.keys()]                    # This simplifies plotting the results of the independent measurements that are done in parallel.
                depend_dict = {}
                if Dependencies is not None:
                    for list_idx, dep_list in enumerate(Dependencies):
                        for dep in dep_list:
                            if dep in data:
                                depend_dict[dep] = names[list_idx]
                                if extra_data is not None and 'Dependencies' in extra_data and dep in extra_data['Dependencies']:
                                    depend_dict[dep] = depend_dict[dep] + extra_data['Dependencies'][dep]
                            else:
                                print("Warning: data variable '" + str(dep) + "' that is given in the dependency list is not found in the data dictionary. This dependency specification will be ignored.") 
                if extra_data is not None and 'Indep Names' in extra_data and 'Indep Vals' in extra_data: # Add the dependency specifications to the RunOnce data that are not single numbers.
                    names = names + extra_data['Indep Names']
                    values = values + extra_data['Indep Vals']
                self._SaveData(names, values, data, depend_dict)    # Save the data.
            else:
                print('There is no data to save!')
 
###KEYBOARD LISTENERS################################################################################
##################################################################################################### 
    def _ListenKeyboard(self, RecogKeys=[27, 83, 115, 84, 116, 79, 111, 88, 120], ClearBuffer=True):
        if kbhit():                                     # Analyze the first character in the keyboard buffer.
            key = getch()
            if ord(key) in RecogKeys:
                if ord(key) == 27:                             # [ESC] is pressed.
                    self._RunStatus = 'abort'
                    self._RunMessage = 'The experiment has been aborted!'
                elif ord(key) == 83 or ord(key) == 115:        # Either [S] or [s] is pressed.
                    self._RunStatus = 'abort-and-save'
                    self._RunMessage = 'The experiment has been aborted!'
                elif ord(key) == 84 or ord(key) == 116:        # Either [T] or [t] is pressed.
                    if self._SweepPointsAcquired > 0:
                        finish_time = time.localtime(self._SweepStartTime + 
                                      self._SweepNumberOfPoints * (time.time() - self._SweepStartTime) / self._SweepPointsAcquired)
                        self._RunMessage = 'The estimated finish time is ' + time.strftime("%H:%M:%S", finish_time) + ' on ' +  time.strftime("%m/%d/%Y", finish_time) + '.'
                    else:
                        self._RunMessage = 'No data has been aquried yet to allow any estimation.'
                elif ord(key) == 79 or ord(key) == 111:        # Either [O] or [o] is pressed.
                     self._StandardOutputFlag = not self._StandardOutputFlag
                elif ord(key) == 88 or ord(key) == 120:        # Either [X] or [x] is pressed.
                     self._RunMessage = 'Hey, stop wondering! Get back to work!'
        if ClearBuffer:                                        # Clear the keyboard buffer.
            while kbhit():
                getch()

###PLOTTING METHODS##################################################################################
#####################################################################################################
    def _Initialize1DPlot(self, values, data, IndependentVars, PlotDataVars):
        # Specify x-axis label.
        xlabel = ''
        for var in self._CombineStrsOrStrLists(IndependentVars):
            xlabel = xlabel + var + self._GetUnitsInBrackets(var) + ', '
        xlabel = xlabel[:-2]
        
        # Specify y-axis label.
        ylabel = ''
        for var in self._CombineStrsOrStrLists(PlotDataVars):
            if var in self._data_vars and 'name' in self._data_vars[var]:
                var = self._data_vars[var]['name']
            ylabel = ylabel + var + self._GetUnitsInBrackets(var) + ', '
        ylabel = ylabel[:-2]
        
        # Initialize the plot.
        plt.figure(1)
        plt.ion()
        plt.clf()
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        
        # Specify line styles.
        self.plot_lines = {}
        for var in PlotDataVars:
            linestyle = 'b-'            # Default line styles and plot parameters. Predefining helps make the code below a bit shorter and
            linewidth = 2               # can potentially reduce severity of the bugs here.
            linelabel = var
            if var in self._data_vars:    # Redefine any plot parameters that are actually specified.
                if 'linestyle' in self._data_vars[var]:
                    linestyle = self._data_vars[var]['linestyle']
                if 'linewidth' in self._data_vars[var]:
                    linewidth = self._data_vars[var]['linewidth']
                if 'legendlabel' in self._data_vars[var]:
                    linelabel = self._data_vars[var]['legendlabel']
            self.plot_lines[var], = plt.plot(values, np.zeros_like(values), linestyle, lw=linewidth, label=linelabel)
        if len(PlotDataVars) > 1:
            plt.legend() 
        
        # Specify axes limits.
        plt.xlim(min(values[0], values[1]), max(values[0], values[1]))  
        self.plot_ymin = None
        self.plot_ymax = None
        for var in PlotDataVars:
            if var in self._data_vars and 'ylim' in self._data_vars[var]:
                if self._data_vars[var]['ylim'][0] is not None:
                    if self.plot_ymin is not None:
                        self.plot_ymin = np.min([self.plot_ymin, self._data_vars[var]['ylim'][0]])
                    else:
                        self.plot_ymin = self._data_vars[var]['ylim'][0]
                if self._data_vars[var]['ylim'][1] is not None:
                    if self.plot_ymax is not None:    
                        self.plot_ymax = np.max([self.plot_ymax, self._data_vars[var]['ylim'][1]])
                    else:
                        self.plot_ymax = self._data_vars[var]['ylim'][1]
        if self.plot_ymin is not None and self.plot_ymax is not None:
            plt.ylim(self.plot_ymin, self.plot_ymax)
        
    def _Update1DPlot(self, values, data, IndependentVars, PlotDataVars):
        plt.figure(1)
        
        # Set data.
        for var in PlotDataVars:
            self.plot_lines[var].set_ydata(data[var])
        
        # Specify axes limits.
        plt.xlim(min(values), max(values))
        if self.plot_ymax is None:
            ymax = np.max([np.max(data[var][0:len(values)]) for var in PlotDataVars])
        else:
            ymax = self.plot_ymax
        if self.plot_ymin is None:
            ymin = np.min([np.min(data[var][0:len(values)]) for var in PlotDataVars])
        else:
            ymin = self.plot_ymin
        if ymin == ymax:
            ymax = ymax + np.finfo(type(ymax)).eps
        plt.ylim(ymin, ymax)
        
        # Redraw.
        plt.draw()
        plt.pause(0.05)

    def _PlotWaveforms(self, values, colors, labels):
        if not isinstance(values, list):
            values = [values]
        if not isinstance(colors, list):
            colors = [colors]
        if not isinstance(labels, list):
            labels = [lables]
        if not len(values) == len(colors) == len(labels):
            return
        time = np.linspace(0, values[0].size - 1, values[0].size)
        plt.figure(2)
        plt.ion()
        plt.clf()
        for idx, val in enumerate(values):
            plt.plot(time, val, colors[idx], label=labels[idx])
        plt.xlim(time[0], time[-1])
        plt.legend()
        plt.xlabel('Time [ns]')
        plt.ylabel('DAC Waveforms [DAC units]')
        plt.draw()
        
    def _PlotHistogram(self, data, number_of_devices=1):
        data = np.array(data)
        plt.figure(3)
        plt.ion()
        plt.clf()
        if number_of_devices == 1: 
            plt.hist(data[0, :], bins=500, range=(0, PREAMP_TIMEOUT), color='b')
        elif number_of_devices == 2:
            plt.hist(data[0, :], bins=500, range=(0, PREAMP_TIMEOUT), color='b', label='JPM A')
            plt.hist(data[1, :], bins=500, range=(0, PREAMP_TIMEOUT), color='r', label='JPM B')
            plt.legend()
        plt.xlabel('Timing Information [PreAmp Time Counts]')
        plt.ylabel('Counts')
        plt.draw()